/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package compiler_sam;

import java.util.ArrayList;
import java.util.Objects;
import java.util.StringTokenizer;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.BadLocationException;
import jdk.internal.org.objectweb.asm.tree.analysis.Value;
import java.util.HashSet;
import java.util.LinkedHashSet;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;

/**
 *
 * @author samir filfil
 */
public class GUI extends javax.swing.JFrame {

    /**
     * Creates new form GUI
     */
    ArrayList<Line_token> Tokens_list = new ArrayList<>();
    ArrayList<String> Just_Line = new ArrayList<>();
    ArrayList<Line_token> Final_Tokens_list = new ArrayList<>();

    //takes chars
    ArrayList<Multi_word_split> Multi_words_list = new ArrayList<>();
    //--
    //Child_of Array_list
    ArrayList<Child_of> child_list = new ArrayList<>();
    //HashSet<String> hSetNumbers = new HashSet(aListNumbers);
    ArrayList<String> complier_list = new ArrayList<>();

    String reserved_words[] = {"var", "do", "block", "return", "begin", "end", "read", "print", "if", "in", "out", "loop", "repeat", "assign", "empty"};
    String Symbols[] = {":", ";", "[", "]", "(", ")"};
    String Reaguler_operation[] = {"=<", "=>", ">", "<", "=!="};
    String Assignment_operation[] = {"="};
    String Artmitic_operation[] = {"+", "–", "-", "/", "*", "^"};
    String other_operatoers[] = {"@", "#", "$", "%", "&", ".", "?", "{", "}", "|", ".", "%", "'", "!", ",", "`", "~"};

    public GUI() {
        initComponents();

    }
    // public variables 
    boolean bad_expr = false;

    void reset_jtext3() {

        for (String line : jTextArea2.getText().split("\\n")) {
            complier_list.add(line);

        }
        jTextArea2.setText("");
        LinkedHashSet<String> lhSetNumbers = new LinkedHashSet(complier_list);

        for (String strNumber : lhSetNumbers) {
            set_feedback(strNumber);
        }

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane6 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jButton4 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jSeparator1 = new javax.swing.JSeparator();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTree2 = new javax.swing.JTree();
        jCheckBox1 = new javax.swing.JCheckBox();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jCheckBox2 = new javax.swing.JCheckBox();
        jLabel9 = new javax.swing.JLabel();

        jScrollPane6.setViewportView(jTree1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Samir Compiler");

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setText("\n var x : y ;\ndo\nbegin\n var x : z ;\n read x ;\n z = x * 2 – 4 ;\n if [ z => 0 ]\nbegin\n read y ;\n z = x + 2 * y ;\nend\n print z + x + y ;\n repeat [ z > 0 ]\nbegin\n print z - y ;\n z = z - 1 ;\nend\nend\nreturn");
        jScrollPane1.setViewportView(jTextArea1);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Number", "Token", "Line", "Class type", "m-word"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane2.setViewportView(jTable1);

        jButton1.setBackground(new java.awt.Color(0, 204, 0));
        jButton1.setText("RUN");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setBackground(new java.awt.Color(255, 51, 51));
        jButton2.setText("Reset");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane3.setViewportView(jTextArea2);

        jLabel1.setText("Compile Output -");

        jButton4.setBackground(new java.awt.Color(204, 204, 204));
        jButton4.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        jButton4.setForeground(new java.awt.Color(0, 51, 51));
        jButton4.setText("Compile");
        jButton4.setEnabled(false);
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jLabel2.setText("Parse Tree (Hir)");

        jLabel3.setText("Code sector");

        jLabel4.setText("Code Lexer");

        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jScrollPane4.setViewportView(jTextArea3);

        jSeparator1.setForeground(new java.awt.Color(0, 0, 0));

        jSeparator2.setForeground(new java.awt.Color(0, 0, 0));

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        jTree2.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        jScrollPane7.setViewportView(jTree2);

        jCheckBox1.setSelected(true);
        jCheckBox1.setText("Re-arrange");
        jCheckBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBox1ActionPerformed(evt);
            }
        });

        jLabel7.setForeground(new java.awt.Color(51, 51, 51));
        jLabel7.setText("Re-arrange Check box : it will arrange the multiple stats in one line into correct positions line by line to avoid the structure error. Because the program parse just state in line. ");

        jLabel8.setText("Parse Tree content");

        jCheckBox2.setSelected(true);
        jCheckBox2.setText(" Deep parsing");
        jCheckBox2.setEnabled(false);

        jLabel9.setForeground(new java.awt.Color(51, 51, 51));
        jLabel9.setText(" Deep parsing : deep analysis is directly based on property grammars. It consists, for a given sentence, in building all the possible subsets of juxtaposed elements that can describe a CFG. ");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jScrollPane1)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(26, 26, 26)
                                            .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 109, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                            .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(7, 7, 7)))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 510, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(layout.createSequentialGroup()
                                            .addGap(21, 21, 21)
                                            .addComponent(jCheckBox2)))))
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane7)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(0, 126, Short.MAX_VALUE)
                                .addComponent(jLabel8)
                                .addGap(176, 176, 176))
                            .addComponent(jScrollPane4)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(4, 4, 4)
                        .addComponent(jCheckBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel4)
                        .addGap(401, 401, 401)
                        .addComponent(jLabel2)
                        .addGap(158, 158, 158))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel7)
                            .addComponent(jLabel9)
                            .addComponent(jLabel6))
                        .addGap(0, 0, Short.MAX_VALUE))))
            .addComponent(jSeparator1)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jSeparator2)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jButton2)
                    .addComponent(jButton4)
                    .addComponent(jCheckBox2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jCheckBox1)
                            .addComponent(jLabel6))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 15, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 531, Short.MAX_VALUE)
                    .addComponent(jScrollPane1)
                    .addComponent(jScrollPane7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel8))
                .addGap(4, 4, 4)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane4)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 105, Short.MAX_VALUE))
                .addGap(6, 6, 6)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel9)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    String remove_this_word(String full_word, String rem_word) {
        int r_w_len = rem_word.length();
        //String word = full_word.substring(r_w_len);
        int start_index = full_word.indexOf(rem_word);
        int end_index = start_index + r_w_len;
        String new_s = full_word.substring(0, start_index) + full_word.substring(end_index, full_word.length());

        return new_s;
    }

    int idx_contain_underscore(String s) {
        char c[] = s.toCharArray();
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (c[i] == '_') {
                count++;
                return count;
            }

        }

        return -1;
    }

    void change_has_to_split_true(String s) {
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            if (get.token.contains(s)) {
                get.has_to_split = true;
            }
        }

    }

    boolean is_reserved_word(String s) {
        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word)) {
                return true;
            }

        }

        return false;
    }

    void split_Mwords() {
        Multi_words_list.clear();
        String s = "";
        String line_number = "";
        int count = 0;
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token lt = Tokens_list.get(i);
            if (lt.has_to_split) {
                s = lt.token;
                line_number = lt.line_number;
                Multi_word_split mws = new Multi_word_split();
                ArrayList<Line_token> MWS_lt_list = new ArrayList<>();
                for (int j = 0; j < s.length(); j++) {
                    try {
                        Line_token lt_obj = new Line_token();
                        //  mws.full_word = s;
                        //  mws.line_code = line_number;
                        lt_obj.line_number = line_number;
                        String s_w = return_word_type(s);
                        lt_obj.token = s_w;
                        System.err.println("sub_words : " + s_w);
                        s = remove_this_word(s, s_w);
                        System.err.println("After_removed_word : " + s);
                        count++;
                        lt_obj.number = count;
                        System.out.println("s_count" + count);
                        MWS_lt_list.add(lt_obj);

                    } catch (Exception e) {
                        System.err.println("pro split_Mwords()");
                    }

                }
                if (MWS_lt_list.size() > 0) {
                    mws.mws_list = MWS_lt_list;
                    Multi_words_list.add(mws);
                } else {
                    System.err.println("is empty line");
                }

            }

        }

    }

    boolean check_multi_word(String s) {

        if (!return_class_type(s).contains("Id") && s.length() < 2) {
            return false;
        }

        if (return_word_type(s).equals(s)) {
            return false;
        }

        return !return_class_type(s).contains("Id");
    }

    boolean check_multi_word_wrw(String s) {

        if (!return_class_type_wrw(s).contains("Id") && s.length() < 2) {
            return false;
        }

        if (return_word_type_wrw(s).equals(s)) {
            return false;
        }

        return !return_class_type_wrw(s).contains("Id");
    }

    String remove_spaces(String line) {
        StringTokenizer st = new StringTokenizer(line, " ");
        StringBuilder sb = new StringBuilder();

        while (st.hasMoreElements()) {
            sb.append(st.nextElement()).append(" ");
        }

        String nameWithProperSpacing = sb.toString();

        System.out.println(nameWithProperSpacing);

//trim leading and trailing white spaces
        nameWithProperSpacing = nameWithProperSpacing.trim();

        return nameWithProperSpacing;
    }

    void establish_table() {
        DefaultTableModel model = (DefaultTableModel) jTable1.getModel();
        Object rowData[] = new Object[5];
        for (int i = 0; i < Tokens_list.size(); i++) {
            Multi_word_split mws = new Multi_word_split();
            int curent_pos = 0;

            rowData[0] = Tokens_list.get(i).number;
            rowData[1] = Tokens_list.get(i).token;
            rowData[2] = Tokens_list.get(i).line_number;
            rowData[3] = Tokens_list.get(i).class_type;
            rowData[4] = Tokens_list.get(i).has_to_split;
            model.addRow(rowData);
        }

    }

    void establish_table_new() {
        DefaultTableModel model = (DefaultTableModel) jTable1.getModel();
        Object rowData[] = new Object[4];
        for (int i = 0; i < Tokens_list.size(); i++) {
            rowData[0] = 0;
            rowData[1] = Tokens_list.get(i).token;
            rowData[2] = Tokens_list.get(i).line_number;
            rowData[3] = Tokens_list.get(i).class_type;

            model.addRow(rowData);
        }

    }

    int index_of_first_num(String s) {
        int count = 0;
        char c[] = s.toCharArray();
        for (int i = 0; i < s.length(); i++) {
            if (Character.isDigit(c[i])) {
                count++;
            } else {
                return count;
            }
        }

        return count;
    }

    void split_line_to_words() {
        int count = 1;

        for (int i = 0; i < Just_Line.size(); i++) {
            String line = Just_Line.get(i);
            char char_line[] = line.toCharArray();
            String word = "";
            for (int j = 0; j < line.length(); j++) {
                if (char_line[j] != ' ') {
                    System.out.println("" + j);
                    word += char_line[j];
                    System.out.println(i + "" + word);

                } else {
                    if (word.isEmpty() || " ".equals(word)) {

                    } else {
                        System.err.println("in else ");

                        char wA[] = word.toCharArray();

                        if (is_contain_number(wA[0] + "") && is_contain_alpha(word)) {
                            System.err.println("First condistion true");
                            // if (is_contain_alpha(word) && is_contain_number(word)) { //GET NUMBER AND ALPHA SPLIT
                            int indx = index_of_first_num(word);
                            String nnumber = word.substring(0, indx);
                            String new_word = nnumber;
                            Line_token t1 = new Line_token(Tokens_list.size() + 1, new_word, i + 1 + "", return_class_type(new_word), check_multi_word(new_word));
                            Tokens_list.add(t1);
                            if (is_contain_known(word.substring(indx, word.length()))) {
                                String sp_word = remove_spaces(split_num_str(word.substring(indx, word.length())));
                                System.err.println("new word: " + word.substring(indx + 1, word.length()));
                                String[] parts = sp_word.split(" ");

                                for (String part : parts) {
                                    System.out.println("compiler_sam.GUI.split_line_to_words()cut down : " + part);
                                    if (part.isEmpty()) {

                                    } else {
                                        Line_token t = new Line_token(Tokens_list.size() + 1, part, i + 1 + "", return_class_type(part), check_multi_word(part));
                                        Tokens_list.add(t);
                                    }

                                }
                            } else {
                                if (word.substring(indx, word.length()).isEmpty()) {

                                } else {
                                    Line_token t2 = new Line_token(Tokens_list.size() + 1, word.substring(indx, word.length()), i + 1 + "", return_class_type(word.substring(indx, word.length())), check_multi_word(word.substring(indx, word.length())));
                                    Tokens_list.add(t2);
                                }
                            }
                            //}
                            word = "";
                        } else if (is_contain_known(wA[0] + "") && is_contain_number(word) && is_contain_alpha(word)) {
                            System.out.println("Second condition true");
                            String sp_word = remove_spaces(split_num_str(word));
                            Line_token t1 = new Line_token(Tokens_list.size() + 1, wA[0] + "", i + 1 + "", return_class_type(wA[0] + ""), check_multi_word(wA[0] + ""));
                            Tokens_list.add(t1);
                            String newword = "";
                            for (int v = 1; v < wA.length; v++) {
                                newword += wA[v];
                            }
                            newword = remove_spaces(split_num_str(newword));

                            String[] parts = newword.split(" ");

                            for (String part : parts) {
                                System.out.println("compiler_sam.GUI.split_line_to_words()cut down : " + part);
                                Line_token t = new Line_token(Tokens_list.size() + 1, part, i + 1 + "", return_class_type(part), check_multi_word(part));
                                Tokens_list.add(t);
                            }
                            word = "";

                        } else if (is_reserved_word(word) && !is_equal_reserved(word)) {
                            System.err.println("Third condition ");
                            String reserv = return_word_type(word);
                            int idx = word.indexOf(reserv);
                            if (is_contain_known_wrw(word)) {
                                System.err.println("2-3-1");
                                String id_w = "";
                                int countid = 0;
                                char c[] = word.toCharArray();
                                for (int g = 0; g < word.length(); g++) {
                                    if (!is_equal_known_wrw(c[g] + "")) {
                                        id_w += c[g] + "";
                                        countid++;
                                    } else {
                                        System.err.println("id_w : " + id_w);

                                        Line_token t = new Line_token(Tokens_list.size() + 1, (id_w), i + 1 + "", "id", false);
                                        Tokens_list.add(t);
                                        break;
                                    }
                                }
                                String rest_word = word.substring(countid, word.length());

                                Line_token t = new Line_token(Tokens_list.size() + 1, (rest_word), i + 1 + "", return_class_type(rest_word), check_multi_word(rest_word));
                                Tokens_list.add(t);
                                word = "";
                            } else {
                                System.err.println("2-3-2");
                                Line_token t = new Line_token(Tokens_list.size() + 1, (word), i + 1 + "", return_class_type_wrw(word), check_multi_word_wrw(word));
                                Tokens_list.add(t);
                                word = "";
                            }

                        } else {
                            System.out.println("compiler_sam.GUI.split_line_to_words()" + word);
                            Line_token t = new Line_token(Tokens_list.size() + 1, (word), i + 1 + "", return_class_type(word), check_multi_word(word));
                            Tokens_list.add(t);
                            word = "";
                        }

                    }

                }
            }
            if (word.isEmpty() || " ".equals(word)) {

            } else {
                try {

                } catch (Exception e) {
                }
                System.err.println("in else two ");

                char wA[] = word.toCharArray();

                if (is_contain_number(wA[0] + "") && is_contain_alpha(word)) {
                    System.err.println("First condistion true");
                    //if (is_contain_alpha(word) && is_contain_number(word)) { //GET NUMBER AND ALPHA SPLIT
                    int indx = index_of_first_num(word);
                    String nnumber = word.substring(0, indx);
                    String new_word = nnumber;
                    Line_token t1 = new Line_token(Tokens_list.size() + 1, new_word, i + 1 + "", return_class_type(new_word), check_multi_word(new_word));
                    Tokens_list.add(t1);

                    if (is_contain_known(word.substring(indx, word.length()))) {
                        String sp_word = remove_spaces(split_num_str(word.substring(indx, word.length())));
                        System.err.println("new word: " + word.substring(indx + 1, word.length()));
                        String[] parts = sp_word.split(" ");

                        for (String part : parts) {
                            System.out.println("compiler_sam.GUI.split_line_to_words()cut down : " + part);
                            if (!part.isEmpty()) {
                                Line_token t = new Line_token(Tokens_list.size() + 1, part, i + 1 + "", return_class_type(part), check_multi_word(part));
                                Tokens_list.add(t);
                            }

                        }
                    } else {
                        if (!word.substring(indx, word.length()).isEmpty()) {
                            Line_token t2 = new Line_token(Tokens_list.size() + 1, word.substring(indx, word.length()), i + 1 + "", return_class_type(word.substring(indx, word.length())), check_multi_word(word.substring(indx, word.length())));
                            Tokens_list.add(t2);
                        }

                    }

                    //}
                    word = "";
                } else if (is_reserved_word(word) && !is_equal_reserved(word)) {
                    System.err.println("Third condition ");
                    String reserv = return_word_type(word);
                    int idx = word.indexOf(reserv);
                    if (is_contain_known_wrw(word)) {
                        System.err.println("2-3-1");
                        String id_w = "";
                        int countid = 0;
                        char c[] = word.toCharArray();
                        for (int j = 0; j < word.length(); j++) {
                            if (!is_equal_known_wrw(c[j] + "")) {
                                id_w += c[j] + "";
                                countid++;
                            } else {
                                System.err.println("id_w : " + id_w);

                                if (is_reserved_word(id_w)) {
                                    Line_token t = new Line_token(Tokens_list.size() + 1, (id_w), i + 1 + "", return_class_type(id_w), false);
                                    Tokens_list.add(t);
                                } else {
                                    Line_token t = new Line_token(Tokens_list.size() + 1, (id_w), i + 1 + "", "id", false);
                                    Tokens_list.add(t);
                                }

                                break;
                            }
                        }
                        String rest_word = word.substring(countid, word.length());

                        Line_token t = new Line_token(Tokens_list.size() + 1, (rest_word), i + 1 + "", return_class_type(rest_word), check_multi_word(rest_word));
                        Tokens_list.add(t);
                        word = "";
                    } else if (is_contain_known(wA[0] + "") && is_contain_number(wA[1] + "")) {

                        System.out.println("Second condition true");
                        String sp_word = remove_spaces(split_num_str(word));
                        Line_token t1 = new Line_token(Tokens_list.size() + 1, wA[0] + "", i + 1 + "", return_class_type(wA[0] + ""), check_multi_word(wA[0] + ""));
                        Tokens_list.add(t1);
                        String newword = "";
                        for (int j = 1; j < wA.length; j++) {
                            newword += wA[j];
                        }
                        newword = remove_spaces(split_num_str(newword));

                        String[] parts = newword.split(" ");

                        for (String part : parts) {
                            System.out.println("compiler_sam.GUI.split_line_to_words()cut down : " + part);
                            Line_token t = new Line_token(Tokens_list.size() + 1, part, i + 1 + "", return_class_type(part), check_multi_word(part));
                            Tokens_list.add(t);
                        }
                        word = "";
                    } else {
                        System.err.println("2-3-2");
                        Line_token t = new Line_token(Tokens_list.size() + 1, (word), i + 1 + "", return_class_type_wrw(word), check_multi_word_wrw(word));
                        Tokens_list.add(t);
                        word = "";
                    }

                } else {
                    System.err.println("Else forth condition ");
                    if (!word.isEmpty()) {
                        Line_token t = new Line_token(Tokens_list.size() + 1, (word), i + 1 + "", return_class_type(word), check_multi_word(word));
                        Tokens_list.add(t);

                        word = "";
                    }

                    word = "";

                }

            }
        }

    }

    String return_class_type(String s) {
        // reserved_words

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word)) {
                return "reserved_word";
            }
        }
        // Symbols
        for (String Symbolsa : Symbols) {
            if (s.contains(Symbolsa)) {
                return "Symbols";
            }
        }
        // Reaguler_operation
        for (String Reaguler_operationo : Reaguler_operation) {
            if (s.contains(Reaguler_operationo)) {
                return "Reaguler operation";
            }
        }
        for (String Assignment_operationo : Assignment_operation) {
            if (s.contains(Assignment_operationo)) {
                return "Assignment_operation";
            }
        }
        for (String Artmitic_operationo : Artmitic_operation) {
            if (s.contains(Artmitic_operationo)) {
                return "Artmitic operation";
            }
        }

        for (String other_operationo : other_operatoers) {
            if (s.contains(other_operationo)) {
                return "Other operetor";
            }
        }

        //check number
        try {
            double n = Double.parseDouble(s);
            return "Number";

        } catch (Exception e) {
        }

        return "Id";
    }

    String return_class_type_wrw(String s) {
        // reserved_words

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word) && idx_contain_underscore(s) != -1) {
                return "Id";
            }
        }

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word) && is_contain_alpha(s)) {
                System.err.println("id returned type");
                return "Id";
            }
        }

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word) && is_contain_number(s)) {
                return "Id";
            }
        }

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word)) {
                return "reserved_word";
            }
        }
        // Symbols
        for (String Symbolsa : Symbols) {
            if (s.contains(Symbolsa)) {
                return "Symbols";
            }
        }
        // Reaguler_operation
        for (String Reaguler_operationo : Reaguler_operation) {
            if (s.contains(Reaguler_operationo)) {
                return "Reaguler operation";
            }
        }

        for (String Assignment_operationo : Assignment_operation) {
            if (s.contains(Assignment_operationo)) {
                return "Assignment_operation";
            }
        }

        for (String Artmitic_operationo : Artmitic_operation) {
            if (s.contains(Artmitic_operationo)) {
                return "Artmitic operation";
            }
        }

        for (String other_operationo : other_operatoers) {
            if (s.contains(other_operationo)) {
                return "Other operetor";
            }
        }

        //check number
        try {
            double n = Double.parseDouble(s);
            return "Number";

        } catch (Exception e) {
        }

        return "Id";
    }

    String put_spaces_between_word(String word, String subword) {
        //passing substring  
        int index_start = word.indexOf(subword);//returns the index of is substring
        char w[] = word.toCharArray();
        boolean flag1 = true;
        boolean flag2 = true;

        int index_end = index_start + subword.length();//returns the index of index substring  

        ArrayList<String> new_word = new ArrayList<>();
        for (int i = 0; i < word.length(); i++) {

            if (index_start == i && flag1) {
                new_word.add(" ");
                i--;
                flag1 = false;
            } else if (index_end == i && flag2) {
                new_word.add(" ");
                i--;
                flag2 = false;

            } else {
                new_word.add(w[i] + "");
            }

        }

        String final_word = "";
        for (int i = 0; i < new_word.size(); i++) {
            String get = new_word.get(i);
            final_word += get;
        }
        return final_word;
    }

    String spacing_word() {
        String ful_word = "";
        String temp_word = "";
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token lt_true = Tokens_list.get(i);
            temp_word = lt_true.token;
            int count = 0;
            if (lt_true.has_to_split) {
                Multi_word_split mws = Multi_words_list.get(count);

                int count_MT = mws.mws_list.size();

                for (int j = 0; j < count_MT; j++) {
                    Line_token lt_in = new Line_token();
                    lt_in = mws.mws_list.get(j);
                    temp_word = put_spaces_between_word(temp_word, lt_in.token);
                    System.out.println(lt_in.line_number + "After split and spacing " + temp_word);
                }
                lt_true.token = temp_word;
                count++;
            }

        }

        return "";
    }

    String return_word_type(String s) {
        // reserved_words

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word)) {
                return reserved_word;
            }
        }
        // Symbols
        for (String Symbolsa : Symbols) {
            if (s.contains(Symbolsa)) {
                return Symbolsa;
            }
        }
        // Reaguler_operation
        for (String Reaguler_operationo : Reaguler_operation) {
            if (s.contains(Reaguler_operationo)) {
                return Reaguler_operationo;
            }
        }

        for (String Artmitic_operationo : Artmitic_operation) {
            if (s.contains(Artmitic_operationo)) {
                return Artmitic_operationo;
            }
        }

        for (String Assignment_operationo : Assignment_operation) {
            if (s.contains(Assignment_operationo)) {
                return Assignment_operationo;
            }
        }

        for (String other_operationo : other_operatoers) {
            if (s.contains(other_operationo)) {
                return other_operationo;
            }
        }

        try {
            double n = Double.parseDouble(remove_str_from_num(s));

            System.out.println("check number return :" + n);
            return n + "";
        } catch (Exception e) {
        }

        return s;
    }

    String return_word_type_wrw(String s) {
        // reserved_words

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word) && is_contain_alpha(s)) {
                return s;
            }
        }

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word) && is_contain_number(s)) {
                return s;
            }
        }

        for (String reserved_word : reserved_words) {
            if (s.contains(reserved_word)) {
                return reserved_word;
            }
        }
        // Symbols
        for (String Symbolsa : Symbols) {
            if (s.contains(Symbolsa)) {
                return Symbolsa;
            }
        }
        // Reaguler_operation
        for (String Reaguler_operationo : Reaguler_operation) {
            if (s.contains(Reaguler_operationo)) {
                return Reaguler_operationo;
            }
        }

        for (String Assignment_operationo : Assignment_operation) {
            if (s.contains(Assignment_operationo)) {
                return Assignment_operationo;
            }
        }

        for (String Artmitic_operationo : Artmitic_operation) {
            if (s.contains(Artmitic_operationo)) {
                return Artmitic_operationo;
            }
        }

        for (String other_operationo : other_operatoers) {
            if (s.contains(other_operationo)) {
                return other_operationo;
            }
        }

        //check number
        try {
            double n = Double.parseDouble(remove_str_from_num(s));

            System.out.println("check number return :" + n);
            return n + "";
        } catch (Exception e) {
        }

        return s;
    }

    String split_num_str(String s) {
        try {

            if (is_contain_number(s) && is_contain_alpha(s)) {
                System.err.println("remove_str_from_num(s) : " + remove_str_from_num(s));
                String s1 = remove_num_string(s);
                System.err.println("remove_str_from_num(s) : " + put_spaces_between_word(s, s1));
                change_has_to_split_true(put_spaces_between_word(s, s1));
                System.err.println("put_spaces_between_word " + put_spaces_between_word(s, s1));
                return put_spaces_between_word(s, s1);
            }

        } catch (Exception e) {
            System.out.println("Splite not done between number and string " + e.getMessage());
        }
        return s;
    }

    boolean is_contain_number(String s) {
        char c[] = s.toCharArray();
        char num[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

        for (int i = 0; i < c.length; i++) {
            char d = c[i];
            for (int j = 0; j < num.length; j++) {
                char e = num[j];
                if (num[j] == c[i]) {
                    return true;
                }

            }

        }

        return false;
    }

    boolean is_contain_known(String s) {

        for (String Artmitic_operation1 : Artmitic_operation) {
            if (s.equals(Artmitic_operation1)) {
                return true;
            }
        }

        for (String sym : Symbols) {
            if (s.equals(sym)) {
                return true;
            }
        }
        for (String op : other_operatoers) {
            if (s.equals(op)) {
                return true;
            }
        }

        for (String sym : reserved_words) {
            if (s.equals(sym)) {
                return true;
            }
        }
        for (String sym : Reaguler_operation) {
            if (s.equals(sym)) {
                return true;
            }
        }

        return false;
    }

    boolean is_contain_known_wrw(String s) {

        for (String Artmitic_operation1 : Artmitic_operation) {
            if (s.contains(Artmitic_operation1)) {
                return true;
            }
        }

        for (String sym : Symbols) {
            if (s.contains(sym)) {
                return true;
            }
        }
        for (String op : other_operatoers) {
            if (s.contains(op)) {
                return true;
            }
        }

        for (String sym : Reaguler_operation) {
            if (s.contains(sym)) {
                return true;
            }
        }

        return false;
    }

    boolean is_equal_known_wrw(String s) {

        for (String Artmitic_operation1 : Artmitic_operation) {
            if (s.equals(Artmitic_operation1)) {
                return true;
            }
        }

        for (String sym : Symbols) {
            if (s.equals(sym)) {
                return true;
            }
        }
        for (String op : other_operatoers) {
            if (s.equals(op)) {
                return true;
            }
        }

        for (String sym : Reaguler_operation) {
            if (s.equals(sym)) {
                return true;
            }
        }

        return false;
    }

    boolean is_equal_reserved(String s) {

        for (String rw : reserved_words) {
            if (s.equals(rw)) {
                return true;
            }
        }

        return false;
    }

    boolean is_contain_alpha(String s) {
        char c[] = s.toCharArray();
        char num[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

        for (int i = 0; i < c.length; i++) {
            char d = c[i];
            for (int j = 0; j < num.length; j++) {
                char e = num[j];
                if (num[j] != c[i]) {
                    return true;
                }

            }

        }

        return false;
    }

    String remove_str_from_num(String str) {

        if (str == null) {
            return null;
        }
        char[] ch = str.toCharArray();
        int length = ch.length;
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (i < length) {
            if (Character.isDigit(ch[i])) {
                i++;
            } else {
                sb.append(ch[i]);
                i++;
            }
        }
        return sb.toString();
    }

    boolean is_knowen() {

        return true;
    }

    String[] cut_words(String word) {
        String[] split_words = {};
        char[] split_chars = {};

        for (int i = 0; i < word.length(); i++) {
            split_chars[i] += word.charAt(i);

        }

        return null;
    }

    ArrayList<Line_token> MAke_new_list(ArrayList<Line_token> Tokens_list1, int num) {
        ArrayList<Line_token> l_t_temp = new ArrayList<>();

        for (int i = 0; i < Tokens_list1.size(); i++) {
            Line_token get = Tokens_list1.get(i);

            if (get.has_to_split) {
                String[] parts = remove_spaces(get.token).split(" ");
                for (String part : parts) {
                    System.err.println(part + "Split done" + num);
                    Line_token l_t_in = new Line_token(l_t_temp.size() + 1, part, get.line_number, return_class_type(part), check_multi_word(part));
                    l_t_temp.add(l_t_in);
                }

            } else {
                l_t_temp.add(get);
            }

        }

        return l_t_temp;
    }

    String remove_num_string(String s) {
        String address = s;
        char[] chars = address.toCharArray();
        String aString = "";

        for (int i = 0; i < chars.length; i++) {
            if (!Character.isDigit(chars[i])) {
                aString = aString + chars[i];

            }

        }
        System.out.println(aString);

        return aString;

    }
    //____________________________________________________________________________________________
    //                                                                                            /
    //                                      PART 2                                                /
    //                                                                                            /            
    //____________________________________________________________________________________________/
    String error_feedback[] = {
        "Syntax Error,Excpected semi-colon at the end insted of",//0
        "Syntax Error,Excpected must begin with begin",//1
        "Syntax Error,Excpected end statment",//2
        "Syntax Error,Excpected return statment",//3
        "Syntax Error,Excpected var statment",//4
        "Syntax Error,Not Excpected Number after var ",//5
        "Syntax Error, Excpected ID after var ",//6
        "Syntax Error,Not Excpected Symbols after var ",//7
        "Syntax Error, Excpected ID : ID between the ':' symbol ",//8
        "Error, Syntex erorr ",//9
        "Syntax Error, Bad operation excpcted exp or ID between the '=' operation ",//10
        "Syntax Error, Bad IF condition excpcted  if [EXPR RO EXPR] ",//11
        "Syntax Error, Bad EXPR excpcted   EXPR  ",//12
        "Syntax Error, Bad EXPR in print statment ",//13
        "Syntax Error, Bad EXPR in read statment - 'Read -> ID -> ;'   ",//14
        "Syntax Error, Bad condition Syntex missing RO ;'   ",//15
        "Syntax Error, Bad condition Syntex '['']' ;'   ",//16
        "Syntax Error, Cannot find symbol'-> ",//17
        "Syntax Error, It could start with ID or Reserved word Only ",//18
        "Syntax Error, Must be begin blook before End ",//19
        "Error -> Missing , The program does not has do BLock ",//20
        "Error -> Missing , there are missing end after the begin ",//21
        "Error -> Missing , there are uncomplete do block -> do - begin ->end ",//22
        "Error -> Missing , 'begin' after do block -> do - begain ->end ",//23
        "Error -> Missing , 'begin' after condition block  ",//24
        "Error -> Missing , 'begin' after repeat block -> do - begain ->end ",//25
        "Syntax Error -> Bad RO -> cant be extra ro next ro ",//26
        "Syntax Error -> Bad RO -> cant be '=' after ro ",//27
        "lexical Error -> The ID cannot start with number ",//28
        "Syntax Error -> the Stats Must be inside dO ->'block,->stat<-end' ",//29
        "<-Warnning->, The best to have one semicolon in row ; ",//30
        "Syntax Error, The end of line must be ';' -> found expr after ",//31
        "Syntax Error, The begin statment must be alone in row 'begin' -> found more expr in row ",//32
        "Syntax Error, The End statment must be alone in row 'end' -> found more expr in row ",//33
        "Syntax Error, the parse not support  Artamitic operation  then ->Artamitic operation in row   ",//34
        "Syntax Error, do block does not complete! it must have do -> block -> return  ",//35
        "Syntax Error, The condition brackets the start does not match the end -> ( <-  -> ) <- ",//36
    };

    void set_feedback(String s) {
        String all_str = jTextArea2.getText();
        jTextArea2.setText(all_str + "\n" + s);
    }

    void set_child_tree(String s) {
        String all_str = jTextArea3.getText();
        jTextArea3.setText(all_str + "\n" + s);
    }

    void set_rearange_line(String s) {
        String all_str = jTextArea1.getText();
        jTextArea1.setText(all_str + "\n" + s);
    }

    void search_Recursive_descent_parser() {

        boolean inside_program = false;
        boolean out_program = false;
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            //_________________________________________
            //                Reserved_word
            //____________________________________________

            try {

                if (inside_program == false && get.token.contains("do")) {
                    inside_program = true;
                } else if (inside_program == true && get.token.contains("do")) {
                    set_feedback("The program unexpected do inside do block, in line " + get.line_number + " the program works just in one do block  ");
                }
                if (out_program == true && get.token.contains("do")) {
                    set_feedback("The program unexpected second do in the program, in line " + get.line_number + " the program works just in one do block  ");

                }
                if (get.token.contains("return")) {
                    inside_program = false;
                    out_program = true;

                }
                if (get.class_type.contains("reserved_word")) {
                    //reserverd repeated in line :
                    check_reserved_inline_stat(Integer.valueOf(get.line_number));

                    if (get.token.contains("var")) {
                        check_var_statment(Integer.valueOf(get.line_number));
                    }

                    if (get.token.contains("if")) {
                        if (inside_program) {
                            check_inline_expr_condition(Integer.valueOf(get.line_number), "if");

                        } else {
                            set_feedback("UnExpected if condition location " + error_feedback[29] + " in line : " + get.line_number);
                            check_inline_expr_condition(Integer.valueOf(get.line_number), "if");

                        }

                    }
                    if (get.token.contains("repeat")) {
                        if (inside_program) {
                            check_inline_expr_condition(Integer.valueOf(get.line_number), "repeat");
                        } else {

                            set_feedback("UnExpected repeat condition location " + error_feedback[29] + " in line : " + get.line_number);
                            check_inline_expr_condition(Integer.valueOf(get.line_number), "repeat");

                        }
                    }
                    //print
                    if (get.token.contains("print")) {
                        if (inside_program) {
                            check_print_stat(Integer.valueOf(get.line_number));
                        } else {
                            set_feedback("UnExpected Print stat location " + error_feedback[29] + " in line : " + get.line_number);
                            check_print_stat(Integer.valueOf(get.line_number));

                        }
                    }
                    //read
                    if (get.token.contains("read")) {
                        if (inside_program) {
                            check_read_stat(Integer.valueOf(get.line_number));
                        } else {
                            set_feedback("UnExpected Read stat location " + error_feedback[29] + " in line : " + get.line_number);
                            check_read_stat(Integer.valueOf(get.line_number));

                        }
                    }
                    if (get.token.contains("begin")) {
                        if (inside_program) {
                            blook(get.number);
                            check_begin_stat(Integer.valueOf(get.line_number));
                        } else {
                            set_feedback("UnExpected begin stat location " + error_feedback[29] + " in line : " + get.line_number);
                            check_begin_stat(Integer.valueOf(get.line_number));

                        }
                    }
                    if (get.token.contains("end")) {
                        if (inside_program) {
                            check_end_stat(Integer.valueOf(get.line_number));
                        } else {
                            set_feedback("UnExpected end stat location " + error_feedback[29] + " in line : " + get.line_number);
                            check_end_stat(Integer.valueOf(get.line_number));

                        }
                    }
                    //_________________________________________
                    //                Symbols
                    //____________________________________________   
                } else if (get.class_type.equals("Symbols")) {
                    check_outliers_ID_correct(Integer.valueOf(get.line_number));

                    //id:id
                    if (get.token.contains(":")) {

                        check_multi_var(Integer.valueOf(get.line_number));
                    }
                    if (get.token.contains(";")) {
                        check_simicolon_stat(Integer.valueOf(get.line_number));
                    }
                    //_________________________________________
                    //                Assignment_operation
                    //____________________________________________   
                } else if (get.class_type.equals("Assignment_operation")) {

                    //id:id
                    try {
                        if (inside_program) {
                            if (!Tokens_list.get(i - 1).class_type.contains("Id")) {
                              //  set_feedback("Syntex error, Expected before Assignment_operation Id but found " + Tokens_list.get(i - 1).token + " in line : " + get.line_number);
                            }
                        } else {
                            set_feedback("UnExpected Assign stat location " + error_feedback[29] + " in line : " + get.line_number);
                        }
                    } catch (Exception e) {
                    }

                    //_________________________________________
                    //               "Reaguler operation
                    //____________________________________________  
                } else if (get.class_type.equals("Reaguler operation")) {

                    //id:id
                    check_RO_stat(Integer.valueOf(get.line_number));

                    //_________________________________________
                    //              Artamitic operations
                    //____________________________________________  
                } else if (get.class_type.equals("Artmitic operation")) {
                    check_outliers_ID_correct(Integer.valueOf(get.line_number));

                    //id:id
                    check_AO_stat(Integer.valueOf(get.line_number));
                    //_________________________________________
                    //                Other symbols
                    //____________________________________________  
                } else if (get.class_type.equals("Other operetor")) {

                    //id:id
                    check_other_stat(Integer.valueOf(get.line_number));
                    //_________________________________________
                    //                BLOCK open 
                    //____________________________________________   check_all states in blocks

                } else if (get.class_type.contains("Id")) {
                    check_outliers_ID_correct(Integer.valueOf(get.line_number));

                    //id = id
                    //id = exp
                    //id = num
                    try {
                        if (Tokens_list.get(i + 1).token.contains("=")) {
                            if (inside_program) {
                                check_end_stat(Integer.valueOf(get.line_number));
                                if (check_inline_expr(Integer.valueOf(get.line_number))) {
                                }
                            } else {
                                set_feedback("UnExpected Assign stat location " + error_feedback[29] + " in line : " + get.line_number);
                                check_end_stat(Integer.valueOf(get.line_number));
                                if (check_inline_expr(Integer.valueOf(get.line_number))) {
                                }
                            }
                            System.out.println("compiler_sam.GUI.search_token_by_token_parser()");
                            if (check_inline_expr(Integer.valueOf(get.line_number))) {
                            }
                        }
                    } catch (Exception e) {
                        // check_inline_expr(Integer.valueOf(get.line_number));
                    }
                } else if (true) {

                    //id:id
                    check_outliers_ID_correct(Integer.valueOf(get.line_number));
                    check_block_first_re(Integer.valueOf(get.line_number));
                    check_block_Num_correct(Integer.valueOf(get.line_number));
                    check_block_ID_correct(Integer.valueOf(get.line_number));
                    //_________________________________________
                    //                ID
                    //____________________________________________   check_other_stat

                }
            } catch (Exception e) {
            }
        }

    }

    void check_code_structure() {
        int count_if = 0;
        int count_repeat = 0;
        int count_begin = 0;
        int count_end = 0;
        int count_do = 0;
        int count_return = 0;
        String do_main = "";
        boolean cont = false;
        int line_err = 0;
        String return_main = "";

        for (int i = 0; i < Tokens_list.size(); i++) {
            //if-repeat structure
            if (Tokens_list.get(i).token.contains("if")) {
                count_if++;
            }
            if (Tokens_list.get(i).token.contains("repeat")) {
                count_repeat++;
            }
            if (Tokens_list.get(i).token.contains("begin")) {
                count_begin++;
            }
            if (Tokens_list.get(i).token.contains("end")) {
                count_end++;
                if (count_end > count_begin && count_begin > 0) {
                    set_feedback("Syntex Error : Unexpected end  stat location the program has  extra end in line : " + Tokens_list.get(i).line_number + " -> The program expected begin stat before the end or remove the extra end. in line : " + Tokens_list.get(i).line_number);
                }
            }
            if (Tokens_list.get(i).token.contains("do")) {
                count_do++;
                if (count_do == 1) {
                    do_main = Tokens_list.get(i).line_number;
                }
                if (count_do > 1) {
                    set_feedback("Syntex Error : Unexpected do stat location the program cannot contain extra do in line : " + Tokens_list.get(i).line_number + " there is main do in line : " + do_main);

                }
            }
            if (Tokens_list.get(i).token.contains("return")) {
                count_return++;
                if (count_return == 1) {
                    return_main = Tokens_list.get(i).line_number;
                }
                if (count_return > count_do) {
                    set_feedback("Syntex Error : Unexpected return location the program cannot contain extra return in line : " + Tokens_list.get(i).line_number + " there is return satement of main program block in line : " + return_main);
                }
            }

        }
        if (cont) {
            //sett error19

        }

        if (count_do != count_return) {
            set_feedback(error_feedback[35] + " missing return at the end of program in the end of  " + Tokens_list.get(Tokens_list.size() - 1).line_number);

        }

        if (count_do < 1) {
            //DET ERR
            set_feedback(error_feedback[20]);

        }
        if (count_do == 0) {
            set_feedback("Warnning, the prgram expected to has (do -> block -> return) but, it is not found! ");

        }
        if (count_begin > count_end) {
            //raise err
            set_feedback(error_feedback[21]);

        }

        if (count_do > 0) {
            if (count_begin - 1 < 0 || count_end - 1 < 0) {
                //raise err do not complete
                set_feedback(error_feedback[22]);

            }

        }

        // DO statment
        boolean err_flag = false;
        int next_line = 0;
        int next_line1 = 0;
        boolean err_flag1 = false;
        boolean thro = false;
        boolean thro1 = false;
        ArrayList<line_parse> if_list_line = new ArrayList<>();
        ArrayList<line_parse> repeat_list_line = new ArrayList<>();

        for (int i = 0; i < Tokens_list.size(); i++) {

            try {
                if (Tokens_list.get(i).token.contains("do")) {
                    if (!Tokens_list.get(i + 1).token.contains("begin")) {
                        //raise err
                        set_feedback(error_feedback[23] + "Expected begin But found " + Tokens_list.get(i + 1).token);

                    }
                }
            } catch (Exception e) {
            }

            // if
            try {
//                if (Tokens_list.get(i).token.equals("if")) {
//
//                    next_line = Integer.valueOf(Tokens_list.get(i).line_number) + 1;
//                    for (int j = 0; j < Tokens_list.size(); j++) {
//                        if (Integer.valueOf(Tokens_list.get(j).line_number) == next_line) {
//                            if (!Tokens_list.get(j).token.equals("begin")) {
//                                set_feedback("Expected begin after if condition But found '" + Tokens_list.get(i).token + "' in line : " + Tokens_list.get(i).line_number);
//
//                            }
//                        }
//
//                    }
//
//                }
            } catch (Exception e) {
            }
            // repeat
//            try {
//                if (Tokens_list.get(i).token.equals("repeat")) {
//                    next_line1 = Integer.valueOf(Tokens_list.get(i).line_number) + 1;
//                    for (int j = 0; j < Tokens_list.size(); j++) {
//                        if (Integer.valueOf(Tokens_list.get(j).line_number) == next_line1) {
//                            if (!Tokens_list.get(j).token.contains("begin")) {
//                                set_feedback("Expected begin after repeat condition But found " + Tokens_list.get(i).token + " in line : " + Tokens_list.get(i).line_number);
//
//                            }
//                        }
//
//                    }
//
//                }
//            } catch (Exception e) {
//            }

        }
//        if (err_flag == true) {
//            System.err.println("fire err if b;ock");
//           
//
//        }

        set_feedback("-> Code Structure Complete successfully ! ");

    }

    void blook(int token_number) {
        int next_end_token_number = 0;
        for (int i = token_number - 1; i < Tokens_list.size(); i++) {
            if (Tokens_list.get(i).token.contains("end")) {
                next_end_token_number = Tokens_list.get(i).number;
                break;
            }

        }

        int var_pos = -1;
        int stat_pos = -1;
        for (int i = token_number; i < next_end_token_number; i++) {
            if (Tokens_list.get(i).token.contains("var")) {
                var_pos = Tokens_list.get(i).number;
            }
            if (Tokens_list.get(i).class_type.contains("reserved_word") && !Tokens_list.get(i).token.contains("var") && !Tokens_list.get(i).token.contains("begin") && !Tokens_list.get(i).token.contains("end") || Tokens_list.get(i).class_type.contains("Assignment_operation")) {
                stat_pos = Tokens_list.get(i).number;
            }
        }
        if (var_pos < stat_pos && var_pos != -1 && stat_pos != -1) {

        }
        if (var_pos > stat_pos && var_pos != -1 && stat_pos != -1) {
            set_feedback("Warnning : IN Block -> var statment came after MSTAT that illegal in context free grammar between the begin and end from line : " + get_line_number(token_number) + " to line :  " + get_line_number(next_end_token_number));
        }
        if (var_pos == -1 && stat_pos == -1) {
            set_feedback("Warnning : The Block is empty between the begin and end from  line : " + get_line_number(token_number) + " to line : " + get_line_number(next_end_token_number) + " it should contain VAR STATS in it.");

        }
        if (var_pos == -1 && stat_pos != -1) {
            // set_feedback("Warnning : The Block is not contain var states line : " + get_line_number(token_number) + " to line : " + get_line_number(next_end_token_number) + " it should contain VAR STATS in it.");

        }
        if (var_pos != -1 && stat_pos == -1) {
            set_feedback("Warnning : The Block is not contain STATS -> if | repeat | print | read <- line : " + get_line_number(token_number) + " to line : " + get_line_number(next_end_token_number) + " it should contain VAR STATS in it.");

        }
    }

    int get_line_number(int pos) {
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            if (get.number == pos) {
                return Integer.valueOf(get.line_number);
            }

        }

        return 0;
    }

    void raise_semicolon_err(int line) {
        set_feedback(error_feedback[0] + "in line - " + line);

    }

    void check_block_ID_correct(int line) {
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag = false;

        for (int i = 0; i < lp_list.size(); i++) {
            try {
                if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).type.contains("Id") && !lp_list.get(i + 1).midel.isEmpty()) {
                    flag = true;
                } else if (lp_list.get(i).type.contains("Id") && lp_list.get(i - 1).type.contains("Id") && !lp_list.get(i - 1).midel.isEmpty()) {
                    flag = true;
//                } else if (lp_list.get(i).type.contains("Id")&&lp_list.get(i-1).type.contains("Number")) {
//                    flag = true;
//                } else if (lp_list.get(i).type.contains("Id")&&lp_list.get(i+1).type.contains("Number")) {
//                    flag = true;
                } else if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).type.contains("reserved_word") && !lp_list.get(i + 1).midel.isEmpty()) {
                    flag = true;
                }

            } catch (Exception e) {
            }

        }

        if (flag == true) {
            set_feedback(error_feedback[9] + "issue between (Number) in line - " + line);
        }

    }

    void check_outliers_ID_correct(int line) {
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag = false;
        boolean outliers = false;
        for (int i = 0; i < lp_list.size(); i++) {
            line_parse get = lp_list.get(i);
            if (lp_list.get(i).type.contains("reserved_word") || lp_list.get(i).midel.contains("=")) {
                outliers = true;
            }
        }

        if (outliers == false) {
            if (lp_list.size() == 1) {
                set_feedback("Unexpected " + lp_list.get(0).type + "  that does not match the grammer Should has STAT ->  IN | OUT | BLOCK | IF | LOOP | ASSIGN in line :  " + line);

            } else {
                set_feedback("Unexpected line or undefined line that does not match the grammer Should has STAT ->  IN | OUT | BLOCK | IF | LOOP | ASSIGN in line : " + line);

            }
        }

    }

    void check_block_Num_correct(int line) {
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag = false;

        for (int i = 0; i < lp_list.size(); i++) {
            try {
                if (lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("Id") && !lp_list.get(i + 1).midel.isEmpty()) {
                    System.err.print("n91");
                    flag = true;
                } else if (lp_list.get(i).type.contains("Number") && lp_list.get(i - 1).type.contains("Id") && !lp_list.get(i - 1).midel.isEmpty()) {
                    System.err.print("n92");

                    flag = true;
                } else if (lp_list.get(i).type.contains("Number") && lp_list.get(i - 1).type.contains("Number") && !lp_list.get(i - 1).midel.isEmpty()) {
                    System.err.print("n93");

                    flag = true;
                } else if (lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("Number") && !lp_list.get(i + 1).midel.isEmpty()) {
                    System.err.print("n94");

                    flag = true;
                } else if (lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("reserved_word") && !lp_list.get(i + 1).midel.isEmpty()) {
                    System.err.print("n95");

                    flag = true;
                }

            } catch (Exception e) {
            }

        }

        if (flag == true) {
            set_feedback(error_feedback[9] + "issue between (Number or ID) in line - " + line);
        }

    }

    void check_block_first_re(int line) {
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag = false;
        if (lp_list.get(0).type.contains("reserved_word")) {
            flag = true;
        } else if (lp_list.get(0).type.contains("Id")) {
            flag = true;
        }

        if (flag == false) {
            set_feedback(error_feedback[9] + " in line - " + line);
        }

    }

    void check_read_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp.number = Tokens_list.get(i).number;
                lp_list.add(lp);

            }
        }
        boolean flag_err = false;
        boolean x = false;
        boolean y = false;
        boolean z = false;

        try {

            if (lp_list.get(0).midel.contains("read")) {
                //   set_rearange_line("read num" + lp_list.size());

                if (lp_list.size() == 1) {
                    set_feedback("Syntex Error : read stat should has 3 tokens, read -> id -> ';' but found : ' " + lp_list.size() + " ' token just read  in line : " + statment_begin_line);

                }
                if (lp_list.size() != 3 && lp_list.size() != 1) {
                    set_feedback("Syntex Error : read stat should has 3 tokens, read -> id -> ';' but found : " + (lp_list.size() - 1) + " tokens after the read token in line : " + statment_begin_line);

                }
                try {
                    if (lp_list.get(1).type.contains("Id")) {
                        try {
                            if (lp_list.get(2).midel.contains(";")) {

                            } else {
                                set_feedback("Syntex Error : Expected ';' but found " + lp_list.get(2).midel + " after the id  in line : " + statment_begin_line);

                            }
                        } catch (Exception e) {
                            set_feedback("Syntex Error : Expected ';' but found " + get_next_token(lp_list.get(1).number) + " after the id  in line : " + statment_begin_line);

                        }

                    } else {
                        set_feedback("Syntex Error : Expected Id but found " + lp_list.get(1).type + " after the read stat in line : " + statment_begin_line);

                    }
                } catch (Exception e) {
                    set_feedback("Syntex Error : read stat should has read -> id -> ';'  after the read stat in line : " + statment_begin_line);

                }

            }

        } catch (Exception e) {
        }

    }

    void check_begin_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }

        if (lp_list.size() > 1) {
            set_feedback(error_feedback[32] + " in line : " + statment_begin_line);
        }

    }

    void check_end_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }

        if (lp_list.size() > 1) {
            //  set_feedback(error_feedback[33] + " in line : " + statment_begin_line);
        }

    }

    void check_AO_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }

        for (int i = 0; i < lp_list.size(); i++) {

            if (lp_list.get(i).type.contains("Artmitic operation")) {
                try {
                    System.out.println("compiler_sam.GUI.check_AO_stat()i n in i ni nin");
                    if (lp_list.get(i).type.contains("Artmitic operation") && lp_list.get(i + 1).type.contains("Artmitic operation") || lp_list.get(i).type.contains("Artmitic operation") && lp_list.get(i - 1).type.contains("Artmitic operation")) {
                        set_feedback(error_feedback[34] + " in line : " + statment_begin_line);
                    }
                } catch (Exception e) {
                }
            }

        }

    }

    void check_reserved_inline_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag_err = false;
        int reserved = 0;
        String eer = "";
        for (int i = 0; i < lp_list.size(); i++) {
            line_parse get = lp_list.get(i);
            if (get.type.contains("reserved_word")) {
                reserved++;
                if (reserved > 1) {
                    set_feedback(error_feedback[9] + " the Reserved Word not in correct location -> " + get.midel + " in line number : " + statment_begin_line);
                }
            }

        }

        // System.err.println("" + lp_list.size());
    }

    void check_other_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        System.err.println("in other exp");
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag_err = false;
        String op = "";
        for (int i = 0; i < lp_list.size(); i++) {
            if (lp_list.get(i).type.contains("Other operetor")) {
                op = lp_list.get(i).midel;
                flag_err = true;
            }

        }
        if (flag_err) {
            set_feedback(error_feedback[17] + "  " + op + " in line number : " + statment_begin_line + "expected defined symbols instead of undefined variable as  " + op);
        }

    }

    void check_RO_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        System.err.println("in print exp");
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag_err = false;

        for (int i = 0; i < lp_list.size(); i++) {

            if (lp_list.get(i).type.contains("Reaguler operation")) {
                try {
                    if (lp_list.get(i + 1).type.contains("Reaguler operation")) {
                        flag_err = true;
                    }

                } catch (Exception e) {
                }
                try {
                    if (lp_list.get(i - 1).type.contains("Reaguler operation")) {
                        flag_err = true;
                    }

                } catch (Exception e) {
                }
                try {
                    if (lp_list.get(i + 1).midel.equals("=")) {
                        set_feedback(error_feedback[27] + "Remove the extra = in line - " + statment_begin_line);
                    }

                } catch (Exception e) {
                }
            }

        }

        if (flag_err == true) {
            set_feedback(error_feedback[26] + "in line - " + statment_begin_line);

        }

    }

    void check_print_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        System.err.println("in print exp");
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp.number = Tokens_list.get(i).number;
                lp_list.add(lp);

            }
        }
        boolean flag_err = false;

        if (lp_list.size() == 1) {
            set_feedback("Syntex Error: Excpected expr after print but found just print statment without expr   '  in line : " + lp_list.get(lp_list.size() - 1).line);
            return;
        }

        if (lp_list.size() == 2) {
            if (lp_list.get(1).midel.contains(";")) {

                set_feedback("Syntex Error: Excpected expr after print but found simicolon   '  in line : " + lp_list.get(lp_list.size() - 1).line);

                return;
            }
            if (lp_list.get(1).type.contains("Id") || lp_list.get(1).type.contains("Number")) {

                set_feedback("Syntex Error: Excpected ; after " + lp_list.get(1).midel + "   '  in line : " + lp_list.get(lp_list.size() - 1).line);

                return;
            }

        }
        if (lp_list.size() == 3) {
            if (lp_list.get(1).type.contains("Id") && lp_list.get(2).midel.contains(";")) {

                return;
            } else if (lp_list.get(1).type.contains("Id") && !lp_list.get(2).midel.contains(";")) {
                set_feedback("Syntex Error: Excpected ; instead of " + lp_list.get(1 + 1).midel + "  in line : " + lp_list.get(lp_list.size() - 1).line);
                return;
            }
            if (lp_list.get(1).type.contains("Number") && lp_list.get(2).midel.contains(";")) {

                return;
            } else if (lp_list.get(1).type.contains("Id") && !lp_list.get(2).midel.contains(";")) {
                set_feedback("Syntex Error: Excpected ; instead of " + lp_list.get(1 + 1).midel + "  in line : " + lp_list.get(lp_list.size() - 1).line);
                return;
            }
        }
        if (lp_list.get(0).midel.contains("print")) { //chech does not effect if statment
//
//            try {
//                if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
//                    set_feedback(error_feedback[0] + " " + lp_list.get(lp_list.size() - 1).midel + " or add simicolon at the end after : " + lp_list.get(lp_list.size() - 1).midel + " in line : " + lp_list.get(lp_list.size() - 1).line);
//                }
//
//                if (lp_list.get(lp_list.size() - 2).type.contains("Artmitic operation")) {
//                    set_feedback("Syntex Error: Excpected simicolon after expr but found '" + lp_list.get(lp_list.size() - 2).midel + "'  in line : " + lp_list.get(lp_list.size() - 1).line);
//                }
//                if (lp_list.get(1).type.contains("Id") || lp_list.get(1).type.contains("Number") || lp_list.get(1).type.contains("Symbols") || lp_list.get(1).midel.contains("-")) {
//
//                } else {
//                    set_feedback("Syntex Error: Expected expr after print stat insted of " + lp_list.get(1).type + " in line : " + lp_list.get(1).line);
//                }
//
//            } catch (Exception e) {
//                set_feedback("Syntex Error: Expected expr -> simicolon after print stat in line : " + lp_list.get(0).line + " but found uncomplete print statment!-> " + get_next_token(lp_list.get(lp_list.size() - 1).number));
//
//            }

        }
        if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
            parse_expr(statment_begin_line, 1, lp_list.size());
        } else {
            parse_expr(statment_begin_line, 1, lp_list.size() - 1);
        }

        if (bad_expr == true) {
            set_feedback(error_feedback[13] + "in line - " + statment_begin_line);

        } else {
            if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
                set_feedback(error_feedback[0] + " '" + get_next_token(lp_list.get(lp_list.size() - 1).number) + "' in line : " + lp_list.get(lp_list.size() - 1).line);
                return;
            }
            if (lp_list.get(lp_list.size() - 2).type.contains("Artmitic operation")) {
                set_feedback("Syntex Error: Excpected simicolon after expr but found '" + lp_list.get(lp_list.size() - 2).midel + "'  in line : " + lp_list.get(lp_list.size() - 1).line);
            }
        }

    }

    void check_simicolon_stat(int statment_begin_line) { //uncomplete
        ArrayList<line_parse> lp_list = new ArrayList<>();
        System.err.println("in print exp");
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }

        int simi_num = 0;
        boolean flag_err = false;
        int token_num = 0;
        for (int i = 0; i < lp_list.size(); i++) {
            line_parse get = lp_list.get(i);
            if (get.midel.contains(";")) {
                simi_num++;

            }
            if (lp_list.get(i).midel.contains(";")) {
                token_num = i;
            }

        }

        for (int i = token_num; i < lp_list.size(); i++) {

            if (lp_list.get(i).type.contains("Id") || lp_list.get(i).type.contains("Number") || lp_list.get(i).type.contains("Reaguler operation") || lp_list.get(i).type.contains("Assignment_operation") || lp_list.get(i).type.contains("Artmitic operation")) {
                set_feedback(error_feedback[31] + " in line - " + statment_begin_line);
            }
            if (simi_num < 2) {
                flag_err = true;

            }
        }

        System.out.println("simicolon ()" + flag_err);
        if (flag_err == false) {
            set_feedback(error_feedback[30] + "in line - " + statment_begin_line);

        }

    }

    void check_inline_expr_condition(int line_number, String reserved_word) {
        ArrayList<line_parse> lp_list = new ArrayList<>();
        int end = 0;
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == line_number) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp.number = Tokens_list.get(i).number;
                lp_list.add(lp);
                System.out.println("compiler_sam.GUI.check_inline_expr_condition()" + lp.midel);
            }
        }
        int opertor_position = 0;
//        System.out.println("lp_list.get(0).type.contains(reserved_word) " + lp_list.get(0).type.contains(reserved_word));

        if (lp_list.size() == 1) {
            set_feedback("Syntex error : expected condition brackets '[' after the condition but just found " + lp_list.get(0).midel + " a reserved word" + " in line : " + lp_list.get(0).line+" but found  "+get_next_token(lp_list.get(0).number)+ " after  "+reserved_word);
            return ;
        }

        if (lp_list.get(0).midel.contains(reserved_word)) {
            for (int j = 0; j < lp_list.size(); j++) {
                line_parse get = lp_list.get(j);
                if (get.type.contains("Reaguler operation")) {
                    opertor_position = j;
                }
            }
            try {
                System.out.println("opertor_position " + opertor_position);
                if (lp_list.get(0).midel.contains(reserved_word)) {
                    if (lp_list.get(1).midel.contains("[")) {
                        if (lp_list.size() == 2) {
                            set_feedback("Syntex error : Expected expr There are missing exper after the [ in line :  " + lp_list.get(0).line +" but found  "+get_next_token(lp_list.get(1).number)+ " after [ "  );
                            return ;
                        }

                    } else {
                        set_feedback("Syntex error : the '[' symbol should be after the " + reserved_word + " condition before of " + lp_list.get(1).midel + " in line : " + lp_list.get(1).line);
                        return ;
                    }
                    if (lp_list.get(2).type.contains("Reaguler operation")) {
                        set_feedback("Syntex error : Expected expr  before  the Reaguler operation -> ' " + lp_list.get(2).midel + "' in line : " + lp_list.get(1).line);

                    }
                    if (lp_list.get(lp_list.size() - 2).type.contains("Reaguler operation") && lp_list.get(lp_list.size() - 1).midel.contains("]")) {
                        set_feedback("Syntex error : Expected expr There are missing exper after the Reaguler operation -> '" + lp_list.get(lp_list.size() - 2).midel + "' in line : " + lp_list.get(1).line);

                    }
                    if (lp_list.get(lp_list.size() - 1).midel.contains("]")) {

                        end = lp_list.size() - 1;
                    } else {

                        end = lp_list.size();

                        // set_feedback("Syntex error : the ']' symbol should be at the end of " + reserved_word + " condition insted of " + lp_list.get(lp_list.size() - 1).midel + " in line : " + lp_list.get(1).line);
                    }
                    // set_feedback(opertor_position+""+ lp_list.size());
                    if (opertor_position == lp_list.size() - 1) {
                        set_feedback("syntex error : expected expr after  " + lp_list.get(opertor_position).midel + " in line : " + line_number+" instead of "+get_next_token(lp_list.get(lp_list.size() - 1).number));
                        return;
                    }
                    //fist exp
                    if (opertor_position > 0) {
                        try {
                            System.err.println("--><--");
                            parse_expr(line_number, 2, opertor_position);
                            if (!bad_expr) {
                                //set_feedback("syntex error : expected true expr after [ insted of : RO  in line : " + line_number);

                                if (lp_list.get(opertor_position - 1).type.contains("Artmitic operation")) {
                                    set_feedback("Expected Reaguler operation  instead of ' " + lp_list.get(opertor_position - 1).midel + " ' in line : " + line_number);
                                    return ;
                                }
                            }

                            System.out.println("check 2 : " + lp_list.get(lp_list.size() - 1).midel);
                            //sec expr
                            System.err.println("--<>--");
                            
    
                            parse_expr(line_number, opertor_position + 1, end);
                            if (!bad_expr) {
                                try {
                                    if (lp_list.get(end - 1).type.contains("Artmitic operation")) {
                                        set_feedback("Expected  ']' instead of ' " + lp_list.get(end - 1).midel + " ' in line : " + line_number);
                                        return ;
                                    }
                                    //set_feedback(lp_list.get(end-1).midel);
                                    if (end == lp_list.size() && !(opertor_position == lp_list.size() - 1)) {
                                        set_feedback("syntex error : expected ] after  : " + lp_list.get(end - 1).midel + " in line : " + line_number +" instead of "+get_next_token(lp_list.get(lp_list.size() - 1).number));
                                        return ;
                                    }

                                } catch (Exception e) {

                                }

                            }
                        } catch (Exception e) {
                        }

                    } else {
                        set_feedback("Syntex error : The " + reserved_word + " condition does not has RO between if[->RO<-]  " + " in line : " + lp_list.get(1).line + " bit the grammer contains -> [EXPR RO EXPR]");
                        return ;
                    }
                }
            } catch (Exception e) {
            }

        }

        if (!get_next_token(lp_list.get(lp_list.size() - 1).number).contains("begin")) {
            set_feedback("Syntex error : After " + reserved_word + " expected begin insted of  " + get_next_token(lp_list.get(lp_list.size() - 1).number) + " in line : " + line_number + " .");

        }

    }

    void check_assi_operator(int statment_begin_line) {
        ArrayList<line_parse> lp_list = new ArrayList<>();

        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

            }
        }
        boolean flag_err = false;

        if (lp_list.get(0).type.contains("reserved_word") && !lp_list.get(0).midel.contains("var")) {
            return;
        }

        for (int i = 0; i < lp_list.size(); i++) {
            //nuber after var error
            try {
                if (lp_list.get(i).midel.contains("=") && lp_list.get(i + 1).type.contains("Reaguler operation")) {
                    set_feedback(error_feedback[10] + "in line - " + statment_begin_line);
                }

                if (lp_list.get(i).midel.contains("=") && lp_list.get(i - 1).type.contains("Reaguler operation")) { //chech does not effect if statment
                    flag_err = true;
                }
                if (lp_list.get(i).midel.contains("=") && lp_list.get(i + 1).type.contains("Id") && lp_list.get(i - 1).type.contains("Id")) {
                    flag_err = true;
                } else if (lp_list.get(i).type.contains("Assignment_operation") && lp_list.get(i + 1).type.contains("Number") && lp_list.get(i - 1).type.contains("Id")) {
                    flag_err = true;
                }
            } catch (Exception e) {
                System.out.println("ERR : 450");
            }

        }

        if (flag_err == false) {
            set_feedback(error_feedback[10] + "in line - " + statment_begin_line);

        }
        if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
            raise_semicolon_err(statment_begin_line);
        }

    }

    void check_multi_var(int statment_begin_line) {

        ArrayList<line_parse> lp_list = new ArrayList<>();
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp_list.add(lp);

                System.out.println("lp.type()" + lp.type);
            }
        }

        for (int i = 0; i < lp_list.size(); i++) {
            //id : id
            try {
                if (lp_list.get(i).midel.contains(":") && !lp_list.get(i + 1).type.contains("Id") && lp_list.get(i - 1).type.contains("Id")) {
                    set_feedback(error_feedback[8] + "in line - " + lp_list.get(i).line);
                } else if (lp_list.get(i).midel.contains(":") && lp_list.get(i + 1).type.contains("Id") && !lp_list.get(i - 1).type.contains("Id")) {
                    set_feedback(error_feedback[8] + "in line - " + lp_list.get(i).line);
                } else if (lp_list.get(i).midel.contains(":") && lp_list.get(i + 1).type.contains("Id") && !lp_list.get(i - 1).type.contains("Id")) {
                    set_feedback(error_feedback[8] + "in line - " + lp_list.get(i).line);
                }
            } catch (Exception e) {
                set_feedback(error_feedback[9] + "in line - " + lp_list.get(i).line);
                break;
            }

        }

    }

    void Check_begin_end() {
        int counter_begain = 0;
        int counter_end = 0;
        int end_line = 0;
        int begin_line = 0;
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            System.out.println("compiler_sam.GUI.Check_begin_end()" + get.class_type);
            if (get.token.equals("begin")) {
                counter_begain++;
                begin_line = 0;

            }

            if (get.token.equals("end")) {
                counter_end++;
                end_line = Integer.valueOf(get.line_number) + 1;
            }

        }
        if (counter_begain > counter_end) {
            set_feedback(error_feedback[2] + " in line :" + end_line);
        }
        if (counter_begain < counter_end) {
            set_feedback(error_feedback[1] + " in line :" + begin_line);
        }
    }

    String get_next_token(int token_number) {
        int is = 0;
        try {
            for (int i = 0; i < Tokens_list.size(); i++) {
                Line_token get = Tokens_list.get(i);
                if (get.number == token_number) {
                    is = i;
                    return Tokens_list.get(i + 1).token;
                }
            }
        } catch (Exception e) {
            set_feedback("Expected 'end' after ' " + Tokens_list.get(is).token + " ' in line : " + (Integer.valueOf(Tokens_list.get(is).line_number) + 1));
        }

        return "";
    }

    void check_var_statment(int statment_line) {
        // VAR -> empty | TYPE id MVARS;
        System.out.println("IN");
        int counter_statment = 0;
        int statment_begin_line = statment_line;
        int statment_end_line = 0;
        ArrayList<String> linv_var_list = new ArrayList<>();
        ArrayList<line_parse> lp_list = new ArrayList<>();

        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                linv_var_list.add(Tokens_list.get(i).token);
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp.number = Tokens_list.get(i).number;
                lp_list.add(lp);

                System.out.println("lp.type()" + lp.type);
            }
        }

        boolean id_f = false;
        int xx = 0;
        for (int i = 0; i < lp_list.size(); i++) {

            if (lp_list.get(i).type.contains("Id")) {
                id_f = true;
            }

            //nuber after var error
            try {

                if (lp_list.get(i).midel.contains("var") && lp_list.get(i + 1).type.contains("Number")) {
                    //set_feedback(error_feedback[5] + "in line - " + lp_list.get(i).line);
                    xx = i;
                }

                if (lp_list.get(i).midel.contains("var") && !lp_list.get(i + 1).type.contains("Id")) {
                   // set_feedback(error_feedback[6] + "in line - " + lp_list.get(i).line);
                    xx = i;
                }
                if (lp_list.get(i).midel.contains("var") && lp_list.get(i + 1).type.contains("Symbols")) {
                    //set_feedback(error_feedback[7] + "in line - " + lp_list.get(i).line);
                    xx = i;
                }
            } catch (Exception e) {
            }
        }
        if (!id_f) {
            set_feedback("syntex error :Excpected ID after var in line " + statment_begin_line + " instead of ' " + get_next_token(lp_list.get(xx).number)+" '");
            return;
        }

        for (int i = 1; i < lp_list.size() - 1; i++) {
            line_parse get = lp_list.get(i);
            if (get.type.contains("Id") || get.midel.contains(":")) {
                try {
                    if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).midel.contains(":")) {

                    } else if (lp_list.get(i + 1).type.contains("Id") && lp_list.get(i).midel.contains(":")) {

                    } else if (lp_list.get(i).type.contains("Id")) {

                    } else {

                        set_feedback("syntex error : Expected  ID after : instead of " + get_next_token(get.number) + " in line -> : " + get.line);
                        return ;
                    }
                } catch (Exception e) {
                }

            } else {
                 set_feedback("syntex error : Expected simicolon or ':' after id instead of " + get.midel + " in line -> : " + get.line);
                 return;
            }
        }
        if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
            if (lp_list.get(lp_list.size() - 1).type.contains("Id")) {
                set_feedback(error_feedback[0] + " '" + get_next_token(lp_list.get(lp_list.size() - 1).number) + "' -> in line - " + statment_begin_line);

            } else {
                set_feedback(error_feedback[0] + " '" + (lp_list.get(lp_list.size() - 1).midel) + "' -> in line - " + statment_begin_line);

            }
        }

    }

    void begin(int postion, String err) {
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            if (get.number == postion + 1) {
                if (!get.token.contains("begin")) {
                    set_feedback(error_feedback[24] + "after " + err + " in line : " + (get.line_number));
                }
            }

        }

    }

    boolean check_inline_expr(int statment_begin_line) {
        ArrayList<line_parse> lp_list = new ArrayList<>();

        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == statment_begin_line) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp.number = Tokens_list.get(i).number;
                lp_list.add(lp);
                System.err.println("" + lp.type);
            }
        }
        int end = 0;
        if (lp_list.get(0).type.contains("Id") && lp_list.get(1).type.contains("Assignment_operation")) {
            
            if (lp_list.size()==2) {
                set_feedback("Syntex Error : expected expr after = instead of '"+get_next_token(lp_list.get(lp_list.size()-1).number) + "' in line : "+statment_begin_line);
                return false ;
            }
    

        if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
            parse_expr(statment_begin_line, 2, lp_list.size());
        } else {
            parse_expr(statment_begin_line, 2, lp_list.size() - 1);
        }

        if (bad_expr == true) {
            set_feedback(error_feedback[13] + "in line - " + statment_begin_line);

        } else {
            if (!lp_list.get(lp_list.size() - 1).midel.contains(";")) {
                set_feedback(error_feedback[0] + " '" + get_next_token(lp_list.get(lp_list.size() - 1).number) + "' in line : " + lp_list.get(lp_list.size() - 1).line);
                return false;
            }
            if (lp_list.get(lp_list.size() - 2).type.contains("Artmitic operation")) {
                set_feedback("Syntex Error: Excpected simicolon after expr but found '" + lp_list.get(lp_list.size() - 2).midel + "'  in line : " + lp_list.get(lp_list.size() - 1).line);
            }
        }
        }
        return true;
        //

    }


    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        String txt = jTextArea1.getText();
        System.out.println("" + txt);
        int lines = jTextArea1.getLineCount();

        try {// Traverse the text in the JTextArea line by line
            for (int i = 0; i < lines; i++) {
                int start = jTextArea1.getLineStartOffset(i);
                int end = jTextArea1.getLineEndOffset(i);
                // Implement method processLine
                Just_Line.add(remove_spaces(jTextArea1.getText(start, end - start)));
            }
        } catch (BadLocationException e) {
            // Handle exception as you see fit
        }
        split_line_to_words();
        split_Mwords();
        spacing_word();
        ArrayList<Line_token> s;

        Tokens_list = MAke_new_list(Tokens_list, 1);

        while (!is_all_splites()) {
            split_Mwords();
            spacing_word();
            Tokens_list = MAke_new_list(Tokens_list, 2);
        }
        mearge_float();
        for (int i = 0; i < Tokens_list.size(); i++) {
            Tokens_list.get(i).number = i + 1;

        }
        ///// rearange 
        if (jCheckBox1.isSelected()) {
            jTextArea1.setText("");
            rearange_lines();

            //reset
            Just_Line.clear();
            Tokens_list.clear();
            Multi_words_list.clear();
            child_list.clear();
            complier_list.clear();
            // remove all table elments
            ((DefaultTableModel) jTable1.getModel()).setRowCount(0);
            jTextArea2.setText("");
            jTextArea3.setText("");

            DefaultTreeModel model = (DefaultTreeModel) jTree2.getModel();
            DefaultMutableTreeNode root = (DefaultMutableTreeNode) model.getRoot();
            root.removeAllChildren();
            model.reload();
            //
            txt = jTextArea1.getText();
            System.out.println("" + txt);
            lines = jTextArea1.getLineCount();

            try {// Traverse the text in the JTextArea line by line
                for (int i = 0; i < lines; i++) {
                    int start = jTextArea1.getLineStartOffset(i);
                    int end = jTextArea1.getLineEndOffset(i);
                    // Implement method processLine
                    Just_Line.add(remove_spaces(jTextArea1.getText(start, end - start)));
                }
            } catch (BadLocationException e) {
                // Handle exception as you see fit
            }
            split_line_to_words();
            split_Mwords();
            spacing_word();

            Tokens_list = MAke_new_list(Tokens_list, 1);

            while (!is_all_splites()) {
                split_Mwords();
                spacing_word();
                Tokens_list = MAke_new_list(Tokens_list, 2);
            }
            mearge_float();
            for (int i = 0; i < Tokens_list.size(); i++) {
                Tokens_list.get(i).number = i + 1;

            }

        }

        System.out.println("CALLSPLITES " + is_all_splites());
        establish_table();

        jButton1.setEnabled(false);
        jButton4.setEnabled(true);
    }//GEN-LAST:event_jButton1ActionPerformed

    boolean is_all_splites() {
        int count = 0;

        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            if (get.has_to_split) {
                count++;
            }

        }
        return count == 0;
    }
    //_______________________________________________________________
    //
    //          TREE PART    
    //_______________________________________________________________

    void Set_childs() {
        System.err.println("Set _childs");

        int tree_depth_num = -1;
        int token_counter = 1;
        int main_line_number = 0;
        int pos = 0;
        int bgn = 0;
        int end = 0;
        ArrayList<Integer> parent_list = new ArrayList<>();
        ArrayList<String> parent_list_names = new ArrayList<>();

        int parent_line = 0;
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Tokens_list.get(i).token.contains("begin")) {
                parent_line = Integer.valueOf(Tokens_list.get(i).line_number);
                parent_list.add(parent_line - 1);
                System.out.println("Print parent line : " + (parent_line - 1));
            }

        }

        for (int i = 0; i < Tokens_list.size(); i++) {
            try {
                for (int j = 0; j < parent_list.size(); j++) {
                    if (Tokens_list.get(i).line_number.contains(parent_list.get(j).toString())) {
                        if (Tokens_list.get(i).token.contains("if") || Tokens_list.get(i).token.contains("do") || Tokens_list.get(i).token.contains("repeat")) {
                            parent_list_names.add(Tokens_list.get(i).token);
                            System.out.println("Print parent name : " + Tokens_list.get(i).token);
                        }

                    }
                }

            } catch (Exception e) {
            }
        }

        for (int i = 0; i < Tokens_list.size(); i++) {

            if (Tokens_list.get(i).token.contains("begin")) {
                tree_depth_num++;
                bgn++;
                continue;
            }
            if (Tokens_list.get(i).token.contains("end")) {
                tree_depth_num--;
                end++;
                continue;
            }

            Child_of cf = new Child_of();
            if (tree_depth_num > -1) {
                try {
                    if (bgn == 2 * end) {
                        cf.Child_depth_num = tree_depth_num;
                        cf.Child_number = token_counter++;
                        cf.Child_of_top = Tokens_list.get(i).class_type;
                        cf.Parent_name = parent_list_names.get(tree_depth_num);
                        cf.midel = Tokens_list.get(i).token;
                        cf.type = Tokens_list.get(i).class_type;
                        cf.line_number = Integer.valueOf(Tokens_list.get(i).line_number);
                        child_list.add(cf);
                    } else {
                        cf.Child_depth_num = tree_depth_num;
                        cf.Child_number = token_counter++;
                        cf.Child_of_top = Tokens_list.get(i).class_type;
                        cf.Parent_name = parent_list_names.get(tree_depth_num);
                        cf.midel = Tokens_list.get(i).token;
                        cf.type = Tokens_list.get(i).class_type;
                        cf.line_number = Integer.valueOf(Tokens_list.get(i).line_number);
                        child_list.add(cf);
                    }
                } catch (Exception e) {
                    System.err.println("err 405");
                }

                System.out.println(cf.toString());

            } else {
                cf.Child_depth_num = tree_depth_num;
                cf.Child_number = token_counter++;
                cf.Child_of_top = Tokens_list.get(i).class_type;
                cf.Parent_name = Tokens_list.get(i).token;
                cf.midel = Tokens_list.get(i).token;
                cf.type = Tokens_list.get(i).class_type;
                cf.line_number = Integer.valueOf(Tokens_list.get(i).line_number);
                child_list.add(cf);

            }

        }
        draw_tree(parent_list_names);
    }

    void mearge_float() {
        ArrayList<Line_token> temp = new ArrayList<>();
        String floa = " ";
        for (int i = 0; i < Tokens_list.size(); i++) {

            if (Tokens_list.get(i).class_type.contains("Number")) {
                try {
                    if (Tokens_list.get(i + 1).token.contains(".")) {
                        if (Tokens_list.get(i).class_type.contains("Number")) {
                            floa = Tokens_list.get(i).token + Tokens_list.get(i + 1).token + Tokens_list.get(i + 2).token;
                            Tokens_list.get(i).token = floa;
                            Tokens_list.get(i + 1).token = "";
                            Tokens_list.get(i + 2).token = "";

                        }
                    }
                } catch (Exception e) {
                }

            }

        }
        try {
            for (int i = 0; i < Tokens_list.size(); i++) {
                Line_token get = Tokens_list.get(i);
                if (!Tokens_list.get(i).token.isEmpty()) {
                    temp.add(get);
                }

            }
        } catch (Exception e) {
        }
        Tokens_list = temp;

    }

    void draw_tree(ArrayList<String> list) {

        DefaultTreeModel model = (DefaultTreeModel) jTree2.getModel();
        DefaultMutableTreeNode root = (DefaultMutableTreeNode) model.getRoot();
        ArrayList<String> s_list = new ArrayList<>();
        String sub_reserved_word;
        String reserved_word = "";
        String line = " -> ";
        String cont = " --- ";
        String sub_parent = "";
        String parent_line = "";
        int bgn = 0;
        int end = 0;
        int temp_line = 0;
        boolean flag_id = false;
        int id_line = 0;
        String indent = "--";
        String indent_start = "|-";
        int INDENT_WIDTH = 4;

        for (int i = 0; i < child_list.size(); i++) {
            flag_id = false;
            id_line = child_list.get(i).line_number;

            for (int j = 0; j < Tokens_list.size(); j++) {
                try {
                    if (Integer.valueOf(Tokens_list.get(i - 1).line_number) == id_line - 1) {
                        if (Tokens_list.get(i).class_type.contains("Id")) {
                            flag_id = true;
                            reserved_word = Tokens_list.get(i).token;
                            break;
                        }
                    }

                } catch (Exception e) {
                }

            }
            try {
                if (!Tokens_list.get(i).token.contains("do")) {
                    if (Tokens_list.get(i).token.contains("if")) {
                        sub_parent = Tokens_list.get(i).token;
                    } else if (Tokens_list.get(i).token.contains("repeat")) {
                        sub_parent = Tokens_list.get(i).token;
                    } else {
                        sub_parent = " Block ";

                    }
                }
            } catch (Exception e) {
                System.out.println("EER : 404");
            }

            if (child_list.get(i).Child_depth_num == -1 && !child_list.get(i).midel.contains("do") || child_list.get(i).Child_depth_num == -1 && !child_list.get(i).midel.contains("return")) {
                // set_feedback(error_feedback[29] + " in line - " + child_list.get(i).line_number);
            }

            if (temp_line != id_line) {
                String s_line = "";
                for (int j = 0; j < s_list.size(); j++) {
                    String get = s_list.get(j);
                    s_line = s_line + line + get;
                }
                set_child_tree("\\-----Line " + temp_line + "----//");
                set_child_tree(parent_line + s_line);
                set_child_tree("");
                set_child_tree("-----TreeDepth = " + (child_list.get(i).Child_depth_num + 1) + "-----");
                s_list.clear();
                parent_line = "";
                System.out.println("");
            }

            if (child_list.get(i).type.contains("reserved_word")) {
                reserved_word = child_list.get(i).midel;
            }
            if (child_list.get(i).Child_depth_num > -1) {
                if (child_list.get(i).Child_depth_num == 0) {
                    if (child_list.get(i).type.contains("Id")) {
                        set_child_tree(child_list.get(i).Parent_name + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");
                    } else if (child_list.get(i).type.contains("Number")) {
                        set_child_tree(indent_start + indent + child_list.get(i).Parent_name + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else {
                        set_child_tree(indent_start + indent + child_list.get(i).Parent_name + line + reserved_word + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add(child_list.get(i).midel);
                        parent_line = "program" + line + child_list.get(i).Parent_name + line + "Block";

                    }
                }
                try {
                    if (child_list.get(i).Child_depth_num == 1) {
                        if (child_list.get(i).type.contains("Id")) {
                            set_child_tree(indent_start + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                            s_list.add("EXPR");

                        } else if (child_list.get(i).type.contains("Number")) {
                            set_child_tree(indent_start + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                            s_list.add("EXPR");

                        } else {
                            set_child_tree(indent_start + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + reserved_word + line + child_list.get(i).type + line + child_list.get(i).midel);
                            s_list.add(child_list.get(i).midel);
                            parent_line = "program" + line + list.get(0) + line + "Block" + line + child_list.get(i).Parent_name + line + "Block";

                        }
                    }
                } catch (Exception e) {
                    System.out.println("exp)");
                }

                if (child_list.get(i).Child_depth_num == 2) {
                    if (child_list.get(i).type.contains("Id")) {
                        set_child_tree(indent_start + indent + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + sub_parent + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else if (child_list.get(i).type.contains("Number")) {
                        set_child_tree(indent_start + indent + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + sub_parent + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else {
                        set_child_tree(indent_start + indent + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + sub_parent + line + reserved_word + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add(child_list.get(i).midel);
                        parent_line = "program" + line + list.get(0) + line + "Block" + line + child_list.get(i).Parent_name + line + "Block";

                    }
                }
                if (child_list.get(i).Child_depth_num == 3) {
                    if (child_list.get(i).type.contains("Id")) {
                        set_child_tree(list.get(0) + line + child_list.get(i).Parent_name + line + sub_parent + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else if (child_list.get(i).type.contains("Number")) {
                        set_child_tree(indent_start + indent + indent + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + sub_parent + line + reserved_word + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else {
                        set_child_tree(indent_start + indent + indent + indent + indent + list.get(0) + line + child_list.get(i).Parent_name + line + sub_parent + line + reserved_word + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add(child_list.get(i).midel);
                        parent_line = "program" + line + list.get(0) + line + "Block" + line + child_list.get(i).Parent_name + line + "Block";

                    }
                }
            } else {

                if (child_list.get(i).type.contains("reserved_word")) {
                    set_child_tree(line + child_list.get(i).midel);
                } else {

                    if (child_list.get(i).type.contains("Id")) {

                        set_child_tree(reserved_word + cont + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else if (child_list.get(i).type.contains("Number")) {
                        set_child_tree(indent_start + reserved_word + cont + line + "EXPR" + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add("EXPR");

                    } else {
                        set_child_tree(indent_start + reserved_word + cont + line + child_list.get(i).type + line + child_list.get(i).midel);
                        s_list.add(child_list.get(i).midel);
                        parent_line = "program" + line + reserved_word;

                    }

                }

            }

            temp_line = child_list.get(i).line_number;

            if (child_list.size() - 1 == i) {
                String s_line = "";
                for (int j = 0; j < s_list.size(); j++) {
                    String get = s_list.get(j);
                    s_line = s_line + line + get;
                }
                set_child_tree("\\-----Line " + temp_line + "----//");
                set_child_tree(parent_line + s_line);
                set_child_tree("");

            }
        }

    }

    void draw_jtree() {
        DefaultTreeModel model = (DefaultTreeModel) jTree2.getModel();
        DefaultMutableTreeNode root = (DefaultMutableTreeNode) model.getRoot();
        DefaultMutableTreeNode prog = new DefaultMutableTreeNode("program");
        DefaultMutableTreeNode do_program = new DefaultMutableTreeNode("Block");
        DefaultMutableTreeNode if_program = new DefaultMutableTreeNode("if");
        DefaultMutableTreeNode repeat_program = new DefaultMutableTreeNode("repeat");
        DefaultMutableTreeNode print_program = new DefaultMutableTreeNode("print");
        DefaultMutableTreeNode read_program = new DefaultMutableTreeNode("read");
        DefaultMutableTreeNode assign_program = new DefaultMutableTreeNode("assign");
        DefaultMutableTreeNode var_program = new DefaultMutableTreeNode("var");
        DefaultMutableTreeNode retuen_program = new DefaultMutableTreeNode("return");
        DefaultMutableTreeNode do_state = new DefaultMutableTreeNode("do");
        DefaultMutableTreeNode if_block_state = new DefaultMutableTreeNode("If_block");
        root.add(prog);
        DefaultMutableTreeNode main_var = new DefaultMutableTreeNode("VAR Sector");
        boolean found_var = false;
        int do_start = get_range_tokens(1, "do");
        for (int i = 0; i < do_start; i++) {
            Line_token get = Tokens_list.get(i);
            if (get.token.contains("var")) {
                var_program = new DefaultMutableTreeNode("var");
                main_var.add(var_program);

                int x = get_range_tokens(get.number, ";");
                for (int j = get.number; j < x; j++) {
                    Line_token get1 = Tokens_list.get(j);
                    var_program.add(new DefaultMutableTreeNode(get1.token));
                    found_var = true;

                }
            }
        }

        DefaultMutableTreeNode block_state = new DefaultMutableTreeNode("Stats Sector");
        DefaultMutableTreeNode Block_var = new DefaultMutableTreeNode("VAR Sector");

        prog.add(main_var);
        prog.add(do_state);
        prog.add(do_program);
        do_program.add(new DefaultMutableTreeNode("begin"));

        do_program.add(Block_var);
        do_program.add(block_state);
        do_program.add(new DefaultMutableTreeNode("end"));

        prog.add(retuen_program);

        for (int i = do_start; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            if (get.class_type.contains("reserved_word") && !get.token.contains("begin") && !get.token.contains("end") && !get.token.contains("do") || get.token.contains("=")) {
                if (get.token.contains("if")) {
                    DefaultMutableTreeNode if_state = new DefaultMutableTreeNode("If");
                    DefaultMutableTreeNode states = new DefaultMutableTreeNode("IF Block");
                    DefaultMutableTreeNode block_var = new DefaultMutableTreeNode("VAR Sector");

                    if_program = new DefaultMutableTreeNode("Stats");

                    block_state.add(if_state);
                    //-----
                    if_state.add(new DefaultMutableTreeNode("IF"));
                    if_state.add(states);

                    states.add(new DefaultMutableTreeNode("begin"));

                    states.add(block_var);
                    states.add(if_program);
                    states.add(new DefaultMutableTreeNode("end"));

                    if (get_range_tokens(get.number, "end") != 0) {
                        for (int j = get.number - 1; j < get_range_tokens(get.number, "end"); j++) {
                            Line_token get1 = Tokens_list.get(j);
                            System.err.println("" + j);
                            if (Tokens_list.get(j).class_type.contains("reserved_word") || Tokens_list.get(j).token.equals("=")) {
                                //_____
                                if (get1.token.contains("read")) {
                                    read_program = new DefaultMutableTreeNode("IN");
                                    if_program.add(read_program);
                                    int x = get_range_tokens(get1.number, ";");
                                    for (int c = get1.number; c < x; c++) {
                                        Line_token get2 = Tokens_list.get(c);
                                        read_program.add(new DefaultMutableTreeNode(get2.token));
                                    }
                                }
                                if (get1.token.contains("print")) {
                                    print_program = new DefaultMutableTreeNode("OUT");
                                    if_program.add(print_program);
                                    int x = get_range_tokens(get1.number, ";");

                                    for (int c = get1.number - 1; c < x; c++) {
                                        Line_token get2 = Tokens_list.get(c);
                                        print_program.add(new DefaultMutableTreeNode(get2.token));

                                    }
                                }
                                if (get1.token.contains("=")) {
                                    assign_program = new DefaultMutableTreeNode("Assign");
                                    if_program.add(assign_program);
                                    int x = get_range_tokens(get1.number, ";");
                                    //  set_rearange_line(" if -> = -> " + x);

                                    try {
                                        for (int c = get1.number - 2; c < x; c++) {
                                            Line_token get2 = Tokens_list.get(c);
                                            assign_program.add(new DefaultMutableTreeNode(get2.token));

                                        }
                                    } catch (Exception e) {

                                    }

                                }

                                if (get1.token.equals("var")) {
                                    var_program = new DefaultMutableTreeNode("Var");
                                    block_var.add(var_program);
                                    int x = get_range_tokens(get1.number, ";");
                                    for (int c = get1.number; c < x; c++) {
                                        Line_token get2 = Tokens_list.get(c);
                                        var_program.add(new DefaultMutableTreeNode(get2.token));

                                    }

                                }
                            }

                        }
                        if (get_range_tokens(get.number, "end") != 0) {
                            i = get_range_tokens(get.number, "end") - 1;
                        }
                    }

                }
                if (get.token.contains("repeat")) {

                    DefaultMutableTreeNode if_state = new DefaultMutableTreeNode("LOOP");
                    DefaultMutableTreeNode states = new DefaultMutableTreeNode("repeat Block");
                    DefaultMutableTreeNode block_var = new DefaultMutableTreeNode("VAR Sector");

                    repeat_program = new DefaultMutableTreeNode("Stats");

                    block_state.add(if_state);
                    //-----
                    if_state.add(new DefaultMutableTreeNode("repeat"));
                    states.add(block_var);
                    states.add(new DefaultMutableTreeNode("begin"));

                    if_state.add(states);
                    states.add(repeat_program);
                    states.add(new DefaultMutableTreeNode("end"));

                    if (get_range_tokens(get.number, "end") != 0) {
                        for (int j = get.number - 1; j < get_range_tokens(get.number, "end"); j++) {
                            Line_token get1 = Tokens_list.get(j);
                            System.err.println("" + j);
                            if (Tokens_list.get(j).class_type.contains("reserved_word") || Tokens_list.get(j).token.equals("=")) {
                                if (get1.token.contains("read")) {
                                    read_program = new DefaultMutableTreeNode("IN");
                                    repeat_program.add(read_program);
                                    int x = get_range_tokens(get1.number, ";");

                                    for (int c = get1.number; c < x; c++) {
                                        Line_token get2 = Tokens_list.get(c);
                                        read_program.add(new DefaultMutableTreeNode(get2.token));

                                    }
                                }
                                if (get1.token.contains("print")) {
                                    print_program = new DefaultMutableTreeNode("OUT");
                                    repeat_program.add(print_program);
                                    int x = get_range_tokens(get1.number, ";");
                                    for (int c = get1.number - 1; c < x; c++) {
                                        Line_token get2 = Tokens_list.get(c);
                                        print_program.add(new DefaultMutableTreeNode(get2.token));

                                    }
                                }
                                if (get1.token.contains("=")) {
                                    assign_program = new DefaultMutableTreeNode("ASSIGN");
                                    repeat_program.add(assign_program);
                                    int x = get_range_tokens(get1.number, ";");
                                    try {
                                        for (int c = get1.number - 2; c < x; c++) {
                                            Line_token get2 = Tokens_list.get(c);
                                            assign_program.add(new DefaultMutableTreeNode(get2.token));

                                        }
                                    } catch (Exception e) {
                                    }

                                }
                                if (get1.token.equals("var")) {
                                    var_program = new DefaultMutableTreeNode("VAR");
                                    block_var.add(var_program);
                                    int x = get_range_tokens(get1.number, ";");
                                    for (int c = get1.number; c < x; c++) {
                                        Line_token get2 = Tokens_list.get(c);
                                        var_program.add(new DefaultMutableTreeNode(get2.token));

                                    }
                                }
                            }

                        }
                        if (get_range_tokens(get.number, "end") != 0) {
                            i = get_range_tokens(get.number, "end") - 1;
                        }
                    }

                }

                if (get.token.contains("print")) {
                    print_program = new DefaultMutableTreeNode("OUT");
                    block_state.add(print_program);

                    int x = get_range_tokens(get.number, ";");
                    for (int j = get.number - 1; j < x; j++) {
                        Line_token get1 = Tokens_list.get(j);
                        print_program.add(new DefaultMutableTreeNode(get1.token));

                    }
                    if (get_range_tokens(get.number, ";") != 0) {
                        i = get_range_tokens(get.number, ";") - 1;

                    }

                }
                if (get.token.contains("var")) {
                    var_program = new DefaultMutableTreeNode("VAR");
                    Block_var.add(var_program);

                    int x = get_range_tokens(get.number, ";");
                    for (int j = get.number; j < x; j++) {
                        Line_token get1 = Tokens_list.get(j);
                        var_program.add(new DefaultMutableTreeNode(get1.token));

                    }

                    if (get_range_tokens(get.number, ";") != 0) {
                        i = get_range_tokens(get.number, ";") - 1;

                    }
                }

                if (get.token.contains("=")) {
                    assign_program = new DefaultMutableTreeNode("ASSIGN");
                    block_state.add(assign_program);
                    int x = get_range_tokens(get.number, ";");
                    try {
                        for (int j = get.number - 2; j < x; j++) {
                            Line_token get1 = Tokens_list.get(j);
                            assign_program.add(new DefaultMutableTreeNode(get1.token));

                        }
                        if (get_range_tokens(get.number, ";") != 0) {
                            i = get_range_tokens(get.number, ";") - 1;
                        }
                    } catch (Exception e) {
                    }

                }

            }

        }
        model.reload(root);

    }

    int get_range_tokens(int token_num, String end_token) {
        try {
            int start = 0;
            int end = 0;
            for (int i = 0; i < Tokens_list.size(); i++) {
                Line_token get = Tokens_list.get(i);
                if (token_num == get.number) {
                    for (int j = token_num - 1; j < Tokens_list.size(); j++) {
                        Line_token get1 = Tokens_list.get(j);
                        if (Tokens_list.get(j).token.contains(end_token)) {

                            return Tokens_list.get(j).number;

                        }

                    }
                }

            }
        } catch (Exception e) {
        }

        return 0;
    }

    //______________________________________________________________
    //test
    void parse_expr(int number, int begin, int end) {
        //set_feedback("parse_expr");
        bad_expr = false;
        int right_brac = 0;
        int left_brac = 0;
        boolean extra_brak = true;
        ArrayList<line_parse> lp_list = new ArrayList<>();
        boolean contain_expr = false;
        for (int i = 0; i < Tokens_list.size(); i++) {
            if (Integer.valueOf(Tokens_list.get(i).line_number) == number) {
                line_parse lp = new line_parse();
                lp.midel = Tokens_list.get(i).token;
                lp.line = Integer.valueOf(Tokens_list.get(i).line_number);
                lp.type = Tokens_list.get(i).class_type;
                lp.number = Tokens_list.get(i).number;
                lp_list.add(lp);
                //   System.err.println("->>>>>parswe >>laprse expr elment : " + lp.midel);
            }
        }
        for (int i = begin; i < end; i++) {
            if (lp_list.get(i).type.contains("Id") || lp_list.get(i).type.contains("Number") && end - begin == 1) {
                contain_expr = true;
                //   return;
            }

        }
        if (contain_expr == false) {
            try {
                set_feedback("Syntex error : Expected expr but found just symbols or Artmitic operation as like ' " + lp_list.get(begin).midel + " ' in line : " + lp_list.get(0).line + " after the : " + lp_list.get(begin - 1).midel);
                bad_expr = true;
                //return;
            } catch (Exception e) {
                set_feedback("catch");
            }

        }

       // set_feedback("parse_expr 1 " + lp_list.get(begin).midel);
       // set_feedback("parse_expr 2 " + lp_list.get(end - 1).midel);

        if (lp_list.get(lp_list.size() - 1).type.contains("Artmitic operation")) {

            set_feedback("Syntex error : Expected expr after the  ' " + lp_list.get(lp_list.size() - 1).midel + " instead of "+get_next_token(lp_list.get(lp_list.size() - 1).number)+"  in line : " + lp_list.get(0).line );

            bad_expr = true;
            return;
        }
        for (int i = begin; i < end; i++) {
            line_parse get = lp_list.get(i);
            // set_rearange_line((end - begin) + "-inside loop : " + get.midel);

            if (get.type.contains("Id") || get.type.contains("Number") || get.type.contains("Symbols") || get.type.contains("Artmitic operation")) {
                if (get.type.contains("Id")) {
                    try {
                        if ((end - begin) == 1) {
                            return;
                        }
                        try {
                            if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).type.contains("Id")) {
                                set_feedback("Syntex error : expected AO after " + lp_list.get(i).midel + " instead of  '" + lp_list.get(i + 1).midel + " in line : " + lp_list.get(i + 1).line);
                                bad_expr = true;
                                return;
                            }
                        } catch (Exception e) {
                        }

                        if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).midel.contains(")") || lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).type.contains("Artmitic operation")) {

                        } else if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).type.contains("Id")) {
                            set_feedback("unexpected id after id " + lp_list.get(i).midel + " -> " + lp_list.get(i + 1).midel + " Expected Artmitic operation or ] before " + lp_list.get(i + 1).midel + " in line : " + lp_list.get(i + 1).line);

                        } else if (lp_list.get(i).type.contains("Id") && lp_list.get(i + 1).type.contains("Number")) {
                            set_feedback("unexpected Number after id " + lp_list.get(i).midel + " -> " + lp_list.get(i + 1).midel + " Expected Artmitic operation before " + lp_list.get(i + 1).midel + " in line : " + lp_list.get(i + 1).line);

                        } else if (lp_list.get(end - 1).type.contains("Id")) {

                        } else {
                            set_feedback("Syntex Error: expected Symbol or artimitic opearation after the ' " + get.midel + " ' " + " in line : " + get.line);
                            bad_expr = true;
                        }
                    } catch (Exception e) {
                        System.out.println("err cauht");
                    }

                }
                if (get.type.contains("Number")) {
                    try {
                        if ((end - begin) == 1) {
                            return;
                        }
                        if (lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("Symbols") || lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("Artmitic operation")) {

                            //set_rearange_line(lp_list.get(end - 1).midel);
                        } else if (lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("Number")) {
                            set_feedback("unexpected Number after Number " + lp_list.get(i).midel + " -> " + lp_list.get(i + 1).midel + " Expected Artmitic operation before " + lp_list.get(i + 1).midel + " in line : " + lp_list.get(i + 1).line);

                        } else if (lp_list.get(i).type.contains("Number") && lp_list.get(i + 1).type.contains("Id")) {
                            set_feedback("unexpected ID after Number " + lp_list.get(i).midel + " -> " + lp_list.get(i + 1).midel + " Expected Artmitic operation before " + lp_list.get(i + 1).midel + " in line : " + lp_list.get(i + 1).line);

                        } else if (lp_list.get(end - 1).type.contains("Number")) {

                        } else {
                            set_feedback("Syntex Error: expected Symbol or artimitic opearation after the number -> ' " + get.midel + " ' " + " in line : " + get.line);
                            bad_expr = true;

                        }
                    } catch (Exception e) {
                    }
                }
                if (get.type.contains("Symbols")) {
                    if (get.midel.contains("(") || get.midel.contains(")")) {
                        try {
                            if ((end - begin) == 1) {
                                set_feedback("Syntex error : Expected expr instead of ' " + get.midel + " ' " + " in line : " + get.line);
                                bad_expr = true;

                            }
                            try {
                                if (get.midel.contains("(") && lp_list.get(i + 1).midel.contains(")")) {
                                    set_feedback("Syntex Error: expected expr inside the (  ) -> ' " + get.midel + " ' " + " in line : " + get.line);
                                    bad_expr = true;

                                }
                            } catch (Exception e) {
                            }

                            if (get.midel.contains("(")) {
                                left_brac++;
                                try {
                                    if (lp_list.get(i + 1).type.contains("Artmitic operation")) {

                                        if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).midel.contains("-") || lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).midel.contains("+")) {

                                        } else {
                                            set_feedback("Syntex Error: expected (- or +) after this Symbol -> ' " + get.midel + " ' instead of ' " + lp_list.get(i + 1).midel + " ' " + " in line : " + get.line);

                                        }

                                    } else {
                                        if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Id")) {

                                        } else if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Number")) {

                                        } else if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Symbols")) {

                                        } else if (lp_list.get(begin).type.contains("Symbols")) {

                                        } else {
                                            set_feedback("Syntex Error: expected ID or NUMBER  after this Symbol -> ' " + get.midel + " ' instead of ' " + lp_list.get(i + 1).midel + " ' " + " in line : " + get.line);
                                            bad_expr = true;

                                        }
                                    }

                                } catch (Exception e) {
                                }

                            }
                            //right symbol
                            if (get.midel.contains(")")) {
                                right_brac++;
                                if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i - 1).type.contains("Artmitic operation")) {
                                    set_feedback("Syntex Error: Expected Expr id or number  after " + lp_list.get(i - 1).midel + "  in line : " + get.line);
                                    bad_expr = true;
                                }

                                if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Artmitic operation") && lp_list.get(i).type.contains("Symbols") && lp_list.get(i - 1).type.contains("Artmitic operation")) {

                                } else if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i - 1).type.contains("Id") && lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Artmitic operation")) {

                                } else if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i - 1).type.contains("Number") && lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Artmitic operation")) {

                                } else if (lp_list.get(i).type.contains("Symbols") && lp_list.get(i + 1).type.contains("Symbols") || lp_list.get(i).type.contains("Symbols") && lp_list.get(i - 1).type.contains("Symbols")) {

                                } else if (lp_list.get(lp_list.size() - 1).type.contains("Symbols")) {

                                } else {
                                    set_feedback("Syntex Error: expected artimitic opearation or symbol after or before this Symbol -> ' " + get.midel + " ' " + " in line : " + get.line);
                                    bad_expr = true;

                                }
                            }
                            if (right_brac > left_brac) {
                                if (extra_brak) {
                                    try {
                                        set_feedback("Syntex Error: UNexpected ')' extra  Symbol after -> ' " + lp_list.get(i - 1).midel + " ' " + " in line : " + get.line);

                                    } catch (Exception e) {
                                    }
                                    extra_brak = false;
                                    bad_expr = true;

                                }

                            }

                        } catch (Exception e) {
                        }

                    } else {
                        set_feedback("Syntex Error: Expected '(' or ')'  symbols rather than " + get.midel + " in line : " + get.line);
                        bad_expr = true;

                    }
                }
                if (get.type.contains("Artmitic operation")) {

                    try {
                        if (get.type.contains("Artmitic operation") && lp_list.size() == 1) {
                            set_feedback("Syntex Error: UnExpected  artimitic opearation  after the ' " + get.midel + " ' " + " in line : " + get.line + "exper not " + get.midel);
                            bad_expr = true;

                        }

                        if (get.type.contains("Artmitic operation") && lp_list.get(i + 1).type.contains("Artmitic operation")) {
                            set_feedback("Syntex Error: UnExpected extra ART opearation  after the ' " + get.midel + " ' " + " in line : " + get.line);
                            bad_expr = true;

                        }

                    } catch (Exception e) {
                    }

                }
            } else {
                set_feedback("Syntex Error: The expr Should only contains () or Id or number or AO insted of : " + get.midel + " in line : " + get.line);
                bad_expr = true;

            }

        }
        if (right_brac < left_brac) {

            set_feedback("Syntex Error: expected ')' extra  Symbol  at the end of expr in line : " + number);
            bad_expr = true;

        }
        //set_feedback("parse_expr " + bad_expr);

    }


    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        Just_Line.clear();
        Tokens_list.clear();
        Multi_words_list.clear();
        child_list.clear();
        complier_list.clear();
        // remove all table elments
        ((DefaultTableModel) jTable1.getModel()).setRowCount(0);
        jTextArea2.setText("");
        jTextArea3.setText("");
        jButton4.setEnabled(false);
        jButton1.setEnabled(true);
        DefaultTreeModel model = (DefaultTreeModel) jTree2.getModel();
        DefaultMutableTreeNode root = (DefaultMutableTreeNode) model.getRoot();
        root.removeAllChildren();
        model.reload();


    }//GEN-LAST:event_jButton2ActionPerformed

    int get_next_important_word(int token_number) {
        for (int i = 0; i < Tokens_list.size(); i++) {
            Line_token get = Tokens_list.get(i);
            if (get.number == token_number) {
                for (int j = get.number + 1; j < Tokens_list.size(); j++) {
                    Line_token get1 = Tokens_list.get(j);
                    if (get1.class_type.contains("reserved_word") || get1.token.contains(";")) {
                        set_feedback("gniw : " + get1.class_type.contains("reserved_word"));
                        if (get1.token.contains(";")) {
                            return get1.number + 1;
                        } else {
                            return get1.number;
                        }

                    }

                }

            }

        }

        return 0;
    }

    void rearange_lines() {
        int new_line = 0;
        int temp_line = 0;
        for (int i = 0; i < Tokens_list.size(); i++) {

            if (Tokens_list.get(i).token.contains("do")) {
                set_rearange_line("do");
            } else if (Tokens_list.get(i).token.contains("if") || Tokens_list.get(i).token.contains("repeat")) {
                int end_num = 0;
                for (int j = i; j < Tokens_list.size(); j++) {
                    Line_token get1 = Tokens_list.get(j);
                    try {
                        if (Tokens_list.get(j).token.contains("]") || Tokens_list.get(j + 1).class_type.contains("reserved_word") || Tokens_list.get(j).token.contains(";")) {
                            end_num = j;
                            break;
                        }
                    } catch (Exception e) {
                        end_num = j;
                        break;
                    }

                }
                String word = "";
                for (int j = i; j <= end_num; j++) {
                    word += " " + Tokens_list.get(j).token;

                }
                if (end_num != 0) {
                    set_rearange_line(word);

                    i = end_num;
                } else {
                    if (get_next_important_word(Tokens_list.get(i).number) != 0) {
                        word = "";

                        for (int j = Tokens_list.get(i).number - 1; j < get_next_important_word(Tokens_list.get(i).number) - 1; j++) {

                            word += " " + Tokens_list.get(j).token;
                        }
                        set_rearange_line(word);
                        i = get_next_important_word(Tokens_list.get(i).number) - 2;
                    } else {
                        //   set_rearange_line(Tokens_list.get(i).token);

                    }
                }

            } else if (Tokens_list.get(i).token.contains("var")) {
                int end_num = 0;
                for (int j = i; j < Tokens_list.size(); j++) {
                    Line_token get1 = Tokens_list.get(j);

                    try {
                        if (Tokens_list.get(j + 1).class_type.contains("reserved_word") || Tokens_list.get(j).token.contains(";")) {
                            end_num = j;
                            break;
                        }
                    } catch (Exception e) {
                        end_num = j;
                        break;
                    }

                }
                String word = "";
                for (int j = i; j <= end_num; j++) {
                    word += " " + Tokens_list.get(j).token;

                }
                if (end_num != 0) {
                    set_rearange_line(word);

                    i = end_num;
                } else {
                    set_rearange_line(Tokens_list.get(i).token);
                }

            } else if (Tokens_list.get(i).token.contains("read")) {
                int end_num = 0;
                for (int j = i; j < Tokens_list.size(); j++) {
                    Line_token get1 = Tokens_list.get(j);

                    try {
                        if (Tokens_list.get(j + 1).class_type.contains("reserved_word") || Tokens_list.get(j).token.contains(";")) {
                            end_num = j;
                            break;
                        }
                    } catch (Exception e) {
                        end_num = j;
                        break;
                    }
                }
                String word = "";
                for (int j = i; j <= end_num; j++) {
                    word += " " + Tokens_list.get(j).token;

                }
                if (end_num != 0) {
                    set_rearange_line(word);

                    i = end_num;
                } else {
                    set_rearange_line(Tokens_list.get(i).token);
                }
            } else if (Tokens_list.get(i).token.contains("print")) {
                int end_num = 0;
                for (int j = i; j < Tokens_list.size(); j++) {
                    Line_token get1 = Tokens_list.get(j);

                    try {
                        if (Tokens_list.get(j + 1).class_type.contains("reserved_word") || Tokens_list.get(j).token.contains(";")) {
                            end_num = j;
                            break;
                        }
                    } catch (Exception e) {
                        end_num = j;
                        break;
                    }
                }
                String word = "";
                for (int j = i; j <= end_num; j++) {
                    word += " " + Tokens_list.get(j).token;

                }
                if (end_num != 0) {
                    set_rearange_line(word);

                    i = end_num;
                } else {
                    set_rearange_line(Tokens_list.get(i).token);
                }

            } else if (Tokens_list.get(i).token.contains("=")) {
                int end_num = 0;
                for (int j = i; j < Tokens_list.size(); j++) {
                    Line_token get1 = Tokens_list.get(j);

                    try {
                        if (Tokens_list.get(j + 1).class_type.contains("reserved_word") || Tokens_list.get(j).token.contains(";")) {
                            end_num = j;
                            break;
                        }
                    } catch (Exception e) {
                        end_num = j;
                        break;
                    }
                }
                String word = "";
                for (int j = i - 1; j <= end_num; j++) {
                    word += " " + Tokens_list.get(j).token;

                }
                if (end_num != 0) {
                    set_rearange_line(word);

                    i = end_num;
                } else {
                    set_rearange_line(Tokens_list.get(i).token);
                }

            } else if (Tokens_list.get(i).token.contains("begin")) {

                set_rearange_line(Tokens_list.get(i).token);

            } else if (Tokens_list.get(i).token.contains("end")) {

                set_rearange_line(Tokens_list.get(i).token);

            } else if (Tokens_list.get(i).token.contains("return")) {

                set_rearange_line(Tokens_list.get(i).token);

            } else if (Tokens_list.get(i).class_type.contains("Number")) {

                set_rearange_line(Tokens_list.get(i).token);

            } else if (Tokens_list.get(i).class_type.contains("Id")) {
                try {
                    if (Tokens_list.get(i + 1).token.contains("=")) {

                    } else {
                        set_rearange_line(Tokens_list.get(i).token);

                    }
                } catch (Exception e) {
                    set_rearange_line(Tokens_list.get(i).token);
                }

            } else {
                set_rearange_line(Tokens_list.get(i).token);
            }

        }
    }


    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        // TODO add your handling code here:
        search_Recursive_descent_parser();
        Set_childs();
        check_code_structure();
        reset_jtext3();
        jButton4.setEnabled(false);
        draw_jtree();

        set_feedback("-> pasre complete successfully !");


    }//GEN-LAST:event_jButton4ActionPerformed

    private void jCheckBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jCheckBox1ActionPerformed

    /**
     * @param args the command line arguments
     */

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton4;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    private javax.swing.JTree jTree1;
    private javax.swing.JTree jTree2;
    // End of variables declaration//GEN-END:variables
}
